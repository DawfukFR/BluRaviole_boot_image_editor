// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: update_metadata.proto

package chromeos_update_engine;

public final class UpdateMetadata {
  private UpdateMetadata() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface ExtentOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.Extent)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional uint64 start_block = 1;</code>
     * @return Whether the startBlock field is set.
     */
    boolean hasStartBlock();
    /**
     * <code>optional uint64 start_block = 1;</code>
     * @return The startBlock.
     */
    long getStartBlock();

    /**
     * <code>optional uint64 num_blocks = 2;</code>
     * @return Whether the numBlocks field is set.
     */
    boolean hasNumBlocks();
    /**
     * <code>optional uint64 num_blocks = 2;</code>
     * @return The numBlocks.
     */
    long getNumBlocks();
  }
  /**
   * Protobuf type {@code chromeos_update_engine.Extent}
   */
  public static final class Extent extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.Extent)
      ExtentOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Extent.newBuilder() to construct.
    private Extent(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Extent() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Extent();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Extent_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Extent_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.Extent.class, chromeos_update_engine.UpdateMetadata.Extent.Builder.class);
    }

    private int bitField0_;
    public static final int START_BLOCK_FIELD_NUMBER = 1;
    private long startBlock_ = 0L;
    /**
     * <code>optional uint64 start_block = 1;</code>
     * @return Whether the startBlock field is set.
     */
    @java.lang.Override
    public boolean hasStartBlock() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional uint64 start_block = 1;</code>
     * @return The startBlock.
     */
    @java.lang.Override
    public long getStartBlock() {
      return startBlock_;
    }

    public static final int NUM_BLOCKS_FIELD_NUMBER = 2;
    private long numBlocks_ = 0L;
    /**
     * <code>optional uint64 num_blocks = 2;</code>
     * @return Whether the numBlocks field is set.
     */
    @java.lang.Override
    public boolean hasNumBlocks() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional uint64 num_blocks = 2;</code>
     * @return The numBlocks.
     */
    @java.lang.Override
    public long getNumBlocks() {
      return numBlocks_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt64(1, startBlock_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(2, numBlocks_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, startBlock_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, numBlocks_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.Extent)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.Extent other = (chromeos_update_engine.UpdateMetadata.Extent) obj;

      if (hasStartBlock() != other.hasStartBlock()) return false;
      if (hasStartBlock()) {
        if (getStartBlock()
            != other.getStartBlock()) return false;
      }
      if (hasNumBlocks() != other.hasNumBlocks()) return false;
      if (hasNumBlocks()) {
        if (getNumBlocks()
            != other.getNumBlocks()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasStartBlock()) {
        hash = (37 * hash) + START_BLOCK_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getStartBlock());
      }
      if (hasNumBlocks()) {
        hash = (37 * hash) + NUM_BLOCKS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getNumBlocks());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.Extent parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.Extent prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chromeos_update_engine.Extent}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.Extent)
        chromeos_update_engine.UpdateMetadata.ExtentOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Extent_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Extent_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.Extent.class, chromeos_update_engine.UpdateMetadata.Extent.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.Extent.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        startBlock_ = 0L;
        numBlocks_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Extent_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.Extent getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.Extent build() {
        chromeos_update_engine.UpdateMetadata.Extent result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.Extent buildPartial() {
        chromeos_update_engine.UpdateMetadata.Extent result = new chromeos_update_engine.UpdateMetadata.Extent(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(chromeos_update_engine.UpdateMetadata.Extent result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.startBlock_ = startBlock_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.numBlocks_ = numBlocks_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.Extent) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.Extent)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.Extent other) {
        if (other == chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance()) return this;
        if (other.hasStartBlock()) {
          setStartBlock(other.getStartBlock());
        }
        if (other.hasNumBlocks()) {
          setNumBlocks(other.getNumBlocks());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                startBlock_ = input.readUInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                numBlocks_ = input.readUInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long startBlock_ ;
      /**
       * <code>optional uint64 start_block = 1;</code>
       * @return Whether the startBlock field is set.
       */
      @java.lang.Override
      public boolean hasStartBlock() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional uint64 start_block = 1;</code>
       * @return The startBlock.
       */
      @java.lang.Override
      public long getStartBlock() {
        return startBlock_;
      }
      /**
       * <code>optional uint64 start_block = 1;</code>
       * @param value The startBlock to set.
       * @return This builder for chaining.
       */
      public Builder setStartBlock(long value) {
        
        startBlock_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint64 start_block = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearStartBlock() {
        bitField0_ = (bitField0_ & ~0x00000001);
        startBlock_ = 0L;
        onChanged();
        return this;
      }

      private long numBlocks_ ;
      /**
       * <code>optional uint64 num_blocks = 2;</code>
       * @return Whether the numBlocks field is set.
       */
      @java.lang.Override
      public boolean hasNumBlocks() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional uint64 num_blocks = 2;</code>
       * @return The numBlocks.
       */
      @java.lang.Override
      public long getNumBlocks() {
        return numBlocks_;
      }
      /**
       * <code>optional uint64 num_blocks = 2;</code>
       * @param value The numBlocks to set.
       * @return This builder for chaining.
       */
      public Builder setNumBlocks(long value) {
        
        numBlocks_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint64 num_blocks = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumBlocks() {
        bitField0_ = (bitField0_ & ~0x00000002);
        numBlocks_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.Extent)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)
    private static final chromeos_update_engine.UpdateMetadata.Extent DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.Extent();
    }

    public static chromeos_update_engine.UpdateMetadata.Extent getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Extent>
        PARSER = new com.google.protobuf.AbstractParser<Extent>() {
      @java.lang.Override
      public Extent parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Extent> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Extent> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SignaturesOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.Signatures)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> 
        getSignaturesList();
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    chromeos_update_engine.UpdateMetadata.Signatures.Signature getSignatures(int index);
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    int getSignaturesCount();
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder> 
        getSignaturesOrBuilderList();
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder getSignaturesOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code chromeos_update_engine.Signatures}
   */
  public static final class Signatures extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.Signatures)
      SignaturesOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Signatures.newBuilder() to construct.
    private Signatures(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Signatures() {
      signatures_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Signatures();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.Signatures.class, chromeos_update_engine.UpdateMetadata.Signatures.Builder.class);
    }

    public interface SignatureOrBuilder extends
        // @@protoc_insertion_point(interface_extends:chromeos_update_engine.Signatures.Signature)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>optional uint32 version = 1 [deprecated = true];</code>
       * @deprecated chromeos_update_engine.Signatures.Signature.version is deprecated.
       *     See update_metadata.proto;l=127
       * @return Whether the version field is set.
       */
      @java.lang.Deprecated boolean hasVersion();
      /**
       * <code>optional uint32 version = 1 [deprecated = true];</code>
       * @deprecated chromeos_update_engine.Signatures.Signature.version is deprecated.
       *     See update_metadata.proto;l=127
       * @return The version.
       */
      @java.lang.Deprecated int getVersion();

      /**
       * <code>optional bytes data = 2;</code>
       * @return Whether the data field is set.
       */
      boolean hasData();
      /**
       * <code>optional bytes data = 2;</code>
       * @return The data.
       */
      com.google.protobuf.ByteString getData();

      /**
       * <pre>
       * The DER encoded signature size of EC keys is nondeterministic for
       * different input of sha256 hash. However, we need the size of the
       * serialized signatures protobuf string to be fixed before signing;
       * because this size is part of the content to be signed. Therefore, we
       * always pad the signature data to the maximum possible signature size of
       * a given key. And the payload verifier will truncate the signature to
       * its correct size based on the value of |unpadded_signature_size|.
       * </pre>
       *
       * <code>optional fixed32 unpadded_signature_size = 3;</code>
       * @return Whether the unpaddedSignatureSize field is set.
       */
      boolean hasUnpaddedSignatureSize();
      /**
       * <pre>
       * The DER encoded signature size of EC keys is nondeterministic for
       * different input of sha256 hash. However, we need the size of the
       * serialized signatures protobuf string to be fixed before signing;
       * because this size is part of the content to be signed. Therefore, we
       * always pad the signature data to the maximum possible signature size of
       * a given key. And the payload verifier will truncate the signature to
       * its correct size based on the value of |unpadded_signature_size|.
       * </pre>
       *
       * <code>optional fixed32 unpadded_signature_size = 3;</code>
       * @return The unpaddedSignatureSize.
       */
      int getUnpaddedSignatureSize();
    }
    /**
     * Protobuf type {@code chromeos_update_engine.Signatures.Signature}
     */
    public static final class Signature extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:chromeos_update_engine.Signatures.Signature)
        SignatureOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Signature.newBuilder() to construct.
      private Signature(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Signature() {
        data_ = com.google.protobuf.ByteString.EMPTY;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new Signature();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.Signatures.Signature.class, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder.class);
      }

      private int bitField0_;
      public static final int VERSION_FIELD_NUMBER = 1;
      private int version_ = 0;
      /**
       * <code>optional uint32 version = 1 [deprecated = true];</code>
       * @deprecated chromeos_update_engine.Signatures.Signature.version is deprecated.
       *     See update_metadata.proto;l=127
       * @return Whether the version field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasVersion() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional uint32 version = 1 [deprecated = true];</code>
       * @deprecated chromeos_update_engine.Signatures.Signature.version is deprecated.
       *     See update_metadata.proto;l=127
       * @return The version.
       */
      @java.lang.Override
      @java.lang.Deprecated public int getVersion() {
        return version_;
      }

      public static final int DATA_FIELD_NUMBER = 2;
      private com.google.protobuf.ByteString data_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>optional bytes data = 2;</code>
       * @return Whether the data field is set.
       */
      @java.lang.Override
      public boolean hasData() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional bytes data = 2;</code>
       * @return The data.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getData() {
        return data_;
      }

      public static final int UNPADDED_SIGNATURE_SIZE_FIELD_NUMBER = 3;
      private int unpaddedSignatureSize_ = 0;
      /**
       * <pre>
       * The DER encoded signature size of EC keys is nondeterministic for
       * different input of sha256 hash. However, we need the size of the
       * serialized signatures protobuf string to be fixed before signing;
       * because this size is part of the content to be signed. Therefore, we
       * always pad the signature data to the maximum possible signature size of
       * a given key. And the payload verifier will truncate the signature to
       * its correct size based on the value of |unpadded_signature_size|.
       * </pre>
       *
       * <code>optional fixed32 unpadded_signature_size = 3;</code>
       * @return Whether the unpaddedSignatureSize field is set.
       */
      @java.lang.Override
      public boolean hasUnpaddedSignatureSize() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The DER encoded signature size of EC keys is nondeterministic for
       * different input of sha256 hash. However, we need the size of the
       * serialized signatures protobuf string to be fixed before signing;
       * because this size is part of the content to be signed. Therefore, we
       * always pad the signature data to the maximum possible signature size of
       * a given key. And the payload verifier will truncate the signature to
       * its correct size based on the value of |unpadded_signature_size|.
       * </pre>
       *
       * <code>optional fixed32 unpadded_signature_size = 3;</code>
       * @return The unpaddedSignatureSize.
       */
      @java.lang.Override
      public int getUnpaddedSignatureSize() {
        return unpaddedSignatureSize_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeUInt32(1, version_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeBytes(2, data_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeFixed32(3, unpaddedSignatureSize_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(1, version_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeBytesSize(2, data_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeFixed32Size(3, unpaddedSignatureSize_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof chromeos_update_engine.UpdateMetadata.Signatures.Signature)) {
          return super.equals(obj);
        }
        chromeos_update_engine.UpdateMetadata.Signatures.Signature other = (chromeos_update_engine.UpdateMetadata.Signatures.Signature) obj;

        if (hasVersion() != other.hasVersion()) return false;
        if (hasVersion()) {
          if (getVersion()
              != other.getVersion()) return false;
        }
        if (hasData() != other.hasData()) return false;
        if (hasData()) {
          if (!getData()
              .equals(other.getData())) return false;
        }
        if (hasUnpaddedSignatureSize() != other.hasUnpaddedSignatureSize()) return false;
        if (hasUnpaddedSignatureSize()) {
          if (getUnpaddedSignatureSize()
              != other.getUnpaddedSignatureSize()) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasVersion()) {
          hash = (37 * hash) + VERSION_FIELD_NUMBER;
          hash = (53 * hash) + getVersion();
        }
        if (hasData()) {
          hash = (37 * hash) + DATA_FIELD_NUMBER;
          hash = (53 * hash) + getData().hashCode();
        }
        if (hasUnpaddedSignatureSize()) {
          hash = (37 * hash) + UNPADDED_SIGNATURE_SIZE_FIELD_NUMBER;
          hash = (53 * hash) + getUnpaddedSignatureSize();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.Signatures.Signature prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code chromeos_update_engine.Signatures.Signature}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:chromeos_update_engine.Signatures.Signature)
          chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  chromeos_update_engine.UpdateMetadata.Signatures.Signature.class, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder.class);
        }

        // Construct using chromeos_update_engine.UpdateMetadata.Signatures.Signature.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          version_ = 0;
          data_ = com.google.protobuf.ByteString.EMPTY;
          unpaddedSignatureSize_ = 0;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_Signature_descriptor;
        }

        @java.lang.Override
        public chromeos_update_engine.UpdateMetadata.Signatures.Signature getDefaultInstanceForType() {
          return chromeos_update_engine.UpdateMetadata.Signatures.Signature.getDefaultInstance();
        }

        @java.lang.Override
        public chromeos_update_engine.UpdateMetadata.Signatures.Signature build() {
          chromeos_update_engine.UpdateMetadata.Signatures.Signature result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public chromeos_update_engine.UpdateMetadata.Signatures.Signature buildPartial() {
          chromeos_update_engine.UpdateMetadata.Signatures.Signature result = new chromeos_update_engine.UpdateMetadata.Signatures.Signature(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(chromeos_update_engine.UpdateMetadata.Signatures.Signature result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.version_ = version_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.data_ = data_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.unpaddedSignatureSize_ = unpaddedSignatureSize_;
            to_bitField0_ |= 0x00000004;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof chromeos_update_engine.UpdateMetadata.Signatures.Signature) {
            return mergeFrom((chromeos_update_engine.UpdateMetadata.Signatures.Signature)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.Signatures.Signature other) {
          if (other == chromeos_update_engine.UpdateMetadata.Signatures.Signature.getDefaultInstance()) return this;
          if (other.hasVersion()) {
            setVersion(other.getVersion());
          }
          if (other.hasData()) {
            setData(other.getData());
          }
          if (other.hasUnpaddedSignatureSize()) {
            setUnpaddedSignatureSize(other.getUnpaddedSignatureSize());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  version_ = input.readUInt32();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 18: {
                  data_ = input.readBytes();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 18
                case 29: {
                  unpaddedSignatureSize_ = input.readFixed32();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 29
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private int version_ ;
        /**
         * <code>optional uint32 version = 1 [deprecated = true];</code>
         * @deprecated chromeos_update_engine.Signatures.Signature.version is deprecated.
         *     See update_metadata.proto;l=127
         * @return Whether the version field is set.
         */
        @java.lang.Override
        @java.lang.Deprecated public boolean hasVersion() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional uint32 version = 1 [deprecated = true];</code>
         * @deprecated chromeos_update_engine.Signatures.Signature.version is deprecated.
         *     See update_metadata.proto;l=127
         * @return The version.
         */
        @java.lang.Override
        @java.lang.Deprecated public int getVersion() {
          return version_;
        }
        /**
         * <code>optional uint32 version = 1 [deprecated = true];</code>
         * @deprecated chromeos_update_engine.Signatures.Signature.version is deprecated.
         *     See update_metadata.proto;l=127
         * @param value The version to set.
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder setVersion(int value) {
          
          version_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <code>optional uint32 version = 1 [deprecated = true];</code>
         * @deprecated chromeos_update_engine.Signatures.Signature.version is deprecated.
         *     See update_metadata.proto;l=127
         * @return This builder for chaining.
         */
        @java.lang.Deprecated public Builder clearVersion() {
          bitField0_ = (bitField0_ & ~0x00000001);
          version_ = 0;
          onChanged();
          return this;
        }

        private com.google.protobuf.ByteString data_ = com.google.protobuf.ByteString.EMPTY;
        /**
         * <code>optional bytes data = 2;</code>
         * @return Whether the data field is set.
         */
        @java.lang.Override
        public boolean hasData() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>optional bytes data = 2;</code>
         * @return The data.
         */
        @java.lang.Override
        public com.google.protobuf.ByteString getData() {
          return data_;
        }
        /**
         * <code>optional bytes data = 2;</code>
         * @param value The data to set.
         * @return This builder for chaining.
         */
        public Builder setData(com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          data_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <code>optional bytes data = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearData() {
          bitField0_ = (bitField0_ & ~0x00000002);
          data_ = getDefaultInstance().getData();
          onChanged();
          return this;
        }

        private int unpaddedSignatureSize_ ;
        /**
         * <pre>
         * The DER encoded signature size of EC keys is nondeterministic for
         * different input of sha256 hash. However, we need the size of the
         * serialized signatures protobuf string to be fixed before signing;
         * because this size is part of the content to be signed. Therefore, we
         * always pad the signature data to the maximum possible signature size of
         * a given key. And the payload verifier will truncate the signature to
         * its correct size based on the value of |unpadded_signature_size|.
         * </pre>
         *
         * <code>optional fixed32 unpadded_signature_size = 3;</code>
         * @return Whether the unpaddedSignatureSize field is set.
         */
        @java.lang.Override
        public boolean hasUnpaddedSignatureSize() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * The DER encoded signature size of EC keys is nondeterministic for
         * different input of sha256 hash. However, we need the size of the
         * serialized signatures protobuf string to be fixed before signing;
         * because this size is part of the content to be signed. Therefore, we
         * always pad the signature data to the maximum possible signature size of
         * a given key. And the payload verifier will truncate the signature to
         * its correct size based on the value of |unpadded_signature_size|.
         * </pre>
         *
         * <code>optional fixed32 unpadded_signature_size = 3;</code>
         * @return The unpaddedSignatureSize.
         */
        @java.lang.Override
        public int getUnpaddedSignatureSize() {
          return unpaddedSignatureSize_;
        }
        /**
         * <pre>
         * The DER encoded signature size of EC keys is nondeterministic for
         * different input of sha256 hash. However, we need the size of the
         * serialized signatures protobuf string to be fixed before signing;
         * because this size is part of the content to be signed. Therefore, we
         * always pad the signature data to the maximum possible signature size of
         * a given key. And the payload verifier will truncate the signature to
         * its correct size based on the value of |unpadded_signature_size|.
         * </pre>
         *
         * <code>optional fixed32 unpadded_signature_size = 3;</code>
         * @param value The unpaddedSignatureSize to set.
         * @return This builder for chaining.
         */
        public Builder setUnpaddedSignatureSize(int value) {
          
          unpaddedSignatureSize_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * The DER encoded signature size of EC keys is nondeterministic for
         * different input of sha256 hash. However, we need the size of the
         * serialized signatures protobuf string to be fixed before signing;
         * because this size is part of the content to be signed. Therefore, we
         * always pad the signature data to the maximum possible signature size of
         * a given key. And the payload verifier will truncate the signature to
         * its correct size based on the value of |unpadded_signature_size|.
         * </pre>
         *
         * <code>optional fixed32 unpadded_signature_size = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearUnpaddedSignatureSize() {
          bitField0_ = (bitField0_ & ~0x00000004);
          unpaddedSignatureSize_ = 0;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:chromeos_update_engine.Signatures.Signature)
      }

      // @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures.Signature)
      private static final chromeos_update_engine.UpdateMetadata.Signatures.Signature DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.Signatures.Signature();
      }

      public static chromeos_update_engine.UpdateMetadata.Signatures.Signature getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<Signature>
          PARSER = new com.google.protobuf.AbstractParser<Signature>() {
        @java.lang.Override
        public Signature parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Signature> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Signature> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public static final int SIGNATURES_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> signatures_;
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> getSignaturesList() {
      return signatures_;
    }
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder> 
        getSignaturesOrBuilderList() {
      return signatures_;
    }
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    @java.lang.Override
    public int getSignaturesCount() {
      return signatures_.size();
    }
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Signatures.Signature getSignatures(int index) {
      return signatures_.get(index);
    }
    /**
     * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder getSignaturesOrBuilder(
        int index) {
      return signatures_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < signatures_.size(); i++) {
        output.writeMessage(1, signatures_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < signatures_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, signatures_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.Signatures)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.Signatures other = (chromeos_update_engine.UpdateMetadata.Signatures) obj;

      if (!getSignaturesList()
          .equals(other.getSignaturesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getSignaturesCount() > 0) {
        hash = (37 * hash) + SIGNATURES_FIELD_NUMBER;
        hash = (53 * hash) + getSignaturesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.Signatures parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.Signatures prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chromeos_update_engine.Signatures}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.Signatures)
        chromeos_update_engine.UpdateMetadata.SignaturesOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.Signatures.class, chromeos_update_engine.UpdateMetadata.Signatures.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.Signatures.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (signaturesBuilder_ == null) {
          signatures_ = java.util.Collections.emptyList();
        } else {
          signatures_ = null;
          signaturesBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_Signatures_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.Signatures getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.Signatures.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.Signatures build() {
        chromeos_update_engine.UpdateMetadata.Signatures result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.Signatures buildPartial() {
        chromeos_update_engine.UpdateMetadata.Signatures result = new chromeos_update_engine.UpdateMetadata.Signatures(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(chromeos_update_engine.UpdateMetadata.Signatures result) {
        if (signaturesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            signatures_ = java.util.Collections.unmodifiableList(signatures_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.signatures_ = signatures_;
        } else {
          result.signatures_ = signaturesBuilder_.build();
        }
      }

      private void buildPartial0(chromeos_update_engine.UpdateMetadata.Signatures result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.Signatures) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.Signatures)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.Signatures other) {
        if (other == chromeos_update_engine.UpdateMetadata.Signatures.getDefaultInstance()) return this;
        if (signaturesBuilder_ == null) {
          if (!other.signatures_.isEmpty()) {
            if (signatures_.isEmpty()) {
              signatures_ = other.signatures_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureSignaturesIsMutable();
              signatures_.addAll(other.signatures_);
            }
            onChanged();
          }
        } else {
          if (!other.signatures_.isEmpty()) {
            if (signaturesBuilder_.isEmpty()) {
              signaturesBuilder_.dispose();
              signaturesBuilder_ = null;
              signatures_ = other.signatures_;
              bitField0_ = (bitField0_ & ~0x00000001);
              signaturesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSignaturesFieldBuilder() : null;
            } else {
              signaturesBuilder_.addAllMessages(other.signatures_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                chromeos_update_engine.UpdateMetadata.Signatures.Signature m =
                    input.readMessage(
                        chromeos_update_engine.UpdateMetadata.Signatures.Signature.PARSER,
                        extensionRegistry);
                if (signaturesBuilder_ == null) {
                  ensureSignaturesIsMutable();
                  signatures_.add(m);
                } else {
                  signaturesBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> signatures_ =
        java.util.Collections.emptyList();
      private void ensureSignaturesIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          signatures_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.Signatures.Signature>(signatures_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Signatures.Signature, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder, chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder> signaturesBuilder_;

      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> getSignaturesList() {
        if (signaturesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(signatures_);
        } else {
          return signaturesBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public int getSignaturesCount() {
        if (signaturesBuilder_ == null) {
          return signatures_.size();
        } else {
          return signaturesBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature getSignatures(int index) {
        if (signaturesBuilder_ == null) {
          return signatures_.get(index);
        } else {
          return signaturesBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder setSignatures(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature value) {
        if (signaturesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignaturesIsMutable();
          signatures_.set(index, value);
          onChanged();
        } else {
          signaturesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder setSignatures(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder builderForValue) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          signatures_.set(index, builderForValue.build());
          onChanged();
        } else {
          signaturesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder addSignatures(chromeos_update_engine.UpdateMetadata.Signatures.Signature value) {
        if (signaturesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignaturesIsMutable();
          signatures_.add(value);
          onChanged();
        } else {
          signaturesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder addSignatures(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature value) {
        if (signaturesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSignaturesIsMutable();
          signatures_.add(index, value);
          onChanged();
        } else {
          signaturesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder addSignatures(
          chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder builderForValue) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          signatures_.add(builderForValue.build());
          onChanged();
        } else {
          signaturesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder addSignatures(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder builderForValue) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          signatures_.add(index, builderForValue.build());
          onChanged();
        } else {
          signaturesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder addAllSignatures(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.Signatures.Signature> values) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, signatures_);
          onChanged();
        } else {
          signaturesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder clearSignatures() {
        if (signaturesBuilder_ == null) {
          signatures_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          signaturesBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public Builder removeSignatures(int index) {
        if (signaturesBuilder_ == null) {
          ensureSignaturesIsMutable();
          signatures_.remove(index);
          onChanged();
        } else {
          signaturesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder getSignaturesBuilder(
          int index) {
        return getSignaturesFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder getSignaturesOrBuilder(
          int index) {
        if (signaturesBuilder_ == null) {
          return signatures_.get(index);  } else {
          return signaturesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder> 
           getSignaturesOrBuilderList() {
        if (signaturesBuilder_ != null) {
          return signaturesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(signatures_);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder addSignaturesBuilder() {
        return getSignaturesFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.Signatures.Signature.getDefaultInstance());
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder addSignaturesBuilder(
          int index) {
        return getSignaturesFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.Signatures.Signature.getDefaultInstance());
      }
      /**
       * <code>repeated .chromeos_update_engine.Signatures.Signature signatures = 1;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder> 
           getSignaturesBuilderList() {
        return getSignaturesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Signatures.Signature, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder, chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder> 
          getSignaturesFieldBuilder() {
        if (signaturesBuilder_ == null) {
          signaturesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Signatures.Signature, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder, chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder>(
                  signatures_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          signatures_ = null;
        }
        return signaturesBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.Signatures)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures)
    private static final chromeos_update_engine.UpdateMetadata.Signatures DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.Signatures();
    }

    public static chromeos_update_engine.UpdateMetadata.Signatures getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<Signatures>
        PARSER = new com.google.protobuf.AbstractParser<Signatures>() {
      @java.lang.Override
      public Signatures parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<Signatures> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Signatures> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Signatures getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PartitionInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.PartitionInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional uint64 size = 1;</code>
     * @return Whether the size field is set.
     */
    boolean hasSize();
    /**
     * <code>optional uint64 size = 1;</code>
     * @return The size.
     */
    long getSize();

    /**
     * <code>optional bytes hash = 2;</code>
     * @return Whether the hash field is set.
     */
    boolean hasHash();
    /**
     * <code>optional bytes hash = 2;</code>
     * @return The hash.
     */
    com.google.protobuf.ByteString getHash();
  }
  /**
   * Protobuf type {@code chromeos_update_engine.PartitionInfo}
   */
  public static final class PartitionInfo extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.PartitionInfo)
      PartitionInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PartitionInfo.newBuilder() to construct.
    private PartitionInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PartitionInfo() {
      hash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PartitionInfo();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.PartitionInfo.class, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder.class);
    }

    private int bitField0_;
    public static final int SIZE_FIELD_NUMBER = 1;
    private long size_ = 0L;
    /**
     * <code>optional uint64 size = 1;</code>
     * @return Whether the size field is set.
     */
    @java.lang.Override
    public boolean hasSize() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional uint64 size = 1;</code>
     * @return The size.
     */
    @java.lang.Override
    public long getSize() {
      return size_;
    }

    public static final int HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString hash_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <code>optional bytes hash = 2;</code>
     * @return Whether the hash field is set.
     */
    @java.lang.Override
    public boolean hasHash() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional bytes hash = 2;</code>
     * @return The hash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getHash() {
      return hash_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt64(1, size_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBytes(2, hash_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, size_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, hash_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.PartitionInfo)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.PartitionInfo other = (chromeos_update_engine.UpdateMetadata.PartitionInfo) obj;

      if (hasSize() != other.hasSize()) return false;
      if (hasSize()) {
        if (getSize()
            != other.getSize()) return false;
      }
      if (hasHash() != other.hasHash()) return false;
      if (hasHash()) {
        if (!getHash()
            .equals(other.getHash())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSize()) {
        hash = (37 * hash) + SIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSize());
      }
      if (hasHash()) {
        hash = (37 * hash) + HASH_FIELD_NUMBER;
        hash = (53 * hash) + getHash().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.PartitionInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chromeos_update_engine.PartitionInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.PartitionInfo)
        chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.PartitionInfo.class, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.PartitionInfo.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        size_ = 0L;
        hash_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionInfo_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.PartitionInfo getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.PartitionInfo build() {
        chromeos_update_engine.UpdateMetadata.PartitionInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.PartitionInfo buildPartial() {
        chromeos_update_engine.UpdateMetadata.PartitionInfo result = new chromeos_update_engine.UpdateMetadata.PartitionInfo(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(chromeos_update_engine.UpdateMetadata.PartitionInfo result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.size_ = size_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.hash_ = hash_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.PartitionInfo) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.PartitionInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.PartitionInfo other) {
        if (other == chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance()) return this;
        if (other.hasSize()) {
          setSize(other.getSize());
        }
        if (other.hasHash()) {
          setHash(other.getHash());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                size_ = input.readUInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 18: {
                hash_ = input.readBytes();
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long size_ ;
      /**
       * <code>optional uint64 size = 1;</code>
       * @return Whether the size field is set.
       */
      @java.lang.Override
      public boolean hasSize() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional uint64 size = 1;</code>
       * @return The size.
       */
      @java.lang.Override
      public long getSize() {
        return size_;
      }
      /**
       * <code>optional uint64 size = 1;</code>
       * @param value The size to set.
       * @return This builder for chaining.
       */
      public Builder setSize(long value) {
        
        size_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint64 size = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSize() {
        bitField0_ = (bitField0_ & ~0x00000001);
        size_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString hash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <code>optional bytes hash = 2;</code>
       * @return Whether the hash field is set.
       */
      @java.lang.Override
      public boolean hasHash() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional bytes hash = 2;</code>
       * @return The hash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getHash() {
        return hash_;
      }
      /**
       * <code>optional bytes hash = 2;</code>
       * @param value The hash to set.
       * @return This builder for chaining.
       */
      public Builder setHash(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        hash_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional bytes hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearHash() {
        bitField0_ = (bitField0_ & ~0x00000002);
        hash_ = getDefaultInstance().getHash();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.PartitionInfo)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionInfo)
    private static final chromeos_update_engine.UpdateMetadata.PartitionInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.PartitionInfo();
    }

    public static chromeos_update_engine.UpdateMetadata.PartitionInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<PartitionInfo>
        PARSER = new com.google.protobuf.AbstractParser<PartitionInfo>() {
      @java.lang.Override
      public PartitionInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<PartitionInfo> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PartitionInfo> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface InstallOperationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.InstallOperation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
     * @return The type.
     */
    chromeos_update_engine.UpdateMetadata.InstallOperation.Type getType();

    /**
     * <pre>
     * Only minor version 6 or newer support 64 bits |data_offset| and
     * |data_length|, older client will read them as uint32.
     * The offset into the delta file (after the protobuf)
     * where the data (if any) is stored
     * </pre>
     *
     * <code>optional uint64 data_offset = 2;</code>
     * @return Whether the dataOffset field is set.
     */
    boolean hasDataOffset();
    /**
     * <pre>
     * Only minor version 6 or newer support 64 bits |data_offset| and
     * |data_length|, older client will read them as uint32.
     * The offset into the delta file (after the protobuf)
     * where the data (if any) is stored
     * </pre>
     *
     * <code>optional uint64 data_offset = 2;</code>
     * @return The dataOffset.
     */
    long getDataOffset();

    /**
     * <pre>
     * The length of the data in the delta file
     * </pre>
     *
     * <code>optional uint64 data_length = 3;</code>
     * @return Whether the dataLength field is set.
     */
    boolean hasDataLength();
    /**
     * <pre>
     * The length of the data in the delta file
     * </pre>
     *
     * <code>optional uint64 data_length = 3;</code>
     * @return The dataLength.
     */
    long getDataLength();

    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.Extent> 
        getSrcExtentsList();
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    chromeos_update_engine.UpdateMetadata.Extent getSrcExtents(int index);
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    int getSrcExtentsCount();
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> 
        getSrcExtentsOrBuilderList();
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getSrcExtentsOrBuilder(
        int index);

    /**
     * <pre>
     * Byte length of src, equal to the number of blocks in src_extents *
     * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
     * pass that external program the number of bytes to read from the blocks we
     * pass it.  This is not used in any other operation.
     * </pre>
     *
     * <code>optional uint64 src_length = 5;</code>
     * @return Whether the srcLength field is set.
     */
    boolean hasSrcLength();
    /**
     * <pre>
     * Byte length of src, equal to the number of blocks in src_extents *
     * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
     * pass that external program the number of bytes to read from the blocks we
     * pass it.  This is not used in any other operation.
     * </pre>
     *
     * <code>optional uint64 src_length = 5;</code>
     * @return The srcLength.
     */
    long getSrcLength();

    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.Extent> 
        getDstExtentsList();
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    chromeos_update_engine.UpdateMetadata.Extent getDstExtents(int index);
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    int getDstExtentsCount();
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> 
        getDstExtentsOrBuilderList();
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getDstExtentsOrBuilder(
        int index);

    /**
     * <pre>
     * Byte length of dst, equal to the number of blocks in dst_extents *
     * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
     * operation.
     * </pre>
     *
     * <code>optional uint64 dst_length = 7;</code>
     * @return Whether the dstLength field is set.
     */
    boolean hasDstLength();
    /**
     * <pre>
     * Byte length of dst, equal to the number of blocks in dst_extents *
     * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
     * operation.
     * </pre>
     *
     * <code>optional uint64 dst_length = 7;</code>
     * @return The dstLength.
     */
    long getDstLength();

    /**
     * <pre>
     * Optional SHA 256 hash of the blob associated with this operation.
     * This is used as a primary validation for http-based downloads and
     * as a defense-in-depth validation for https-based downloads. If
     * the operation doesn't refer to any blob, this field will have
     * zero bytes.
     * </pre>
     *
     * <code>optional bytes data_sha256_hash = 8;</code>
     * @return Whether the dataSha256Hash field is set.
     */
    boolean hasDataSha256Hash();
    /**
     * <pre>
     * Optional SHA 256 hash of the blob associated with this operation.
     * This is used as a primary validation for http-based downloads and
     * as a defense-in-depth validation for https-based downloads. If
     * the operation doesn't refer to any blob, this field will have
     * zero bytes.
     * </pre>
     *
     * <code>optional bytes data_sha256_hash = 8;</code>
     * @return The dataSha256Hash.
     */
    com.google.protobuf.ByteString getDataSha256Hash();

    /**
     * <pre>
     * Indicates the SHA 256 hash of the source data referenced in src_extents at
     * the time of applying the operation. If present, the update_engine daemon
     * MUST read and verify the source data before applying the operation.
     * </pre>
     *
     * <code>optional bytes src_sha256_hash = 9;</code>
     * @return Whether the srcSha256Hash field is set.
     */
    boolean hasSrcSha256Hash();
    /**
     * <pre>
     * Indicates the SHA 256 hash of the source data referenced in src_extents at
     * the time of applying the operation. If present, the update_engine daemon
     * MUST read and verify the source data before applying the operation.
     * </pre>
     *
     * <code>optional bytes src_sha256_hash = 9;</code>
     * @return The srcSha256Hash.
     */
    com.google.protobuf.ByteString getSrcSha256Hash();
  }
  /**
   * Protobuf type {@code chromeos_update_engine.InstallOperation}
   */
  public static final class InstallOperation extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.InstallOperation)
      InstallOperationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use InstallOperation.newBuilder() to construct.
    private InstallOperation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private InstallOperation() {
      type_ = 0;
      srcExtents_ = java.util.Collections.emptyList();
      dstExtents_ = java.util.Collections.emptyList();
      dataSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
      srcSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new InstallOperation();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.InstallOperation.class, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder.class);
    }

    /**
     * Protobuf enum {@code chromeos_update_engine.InstallOperation.Type}
     */
    public enum Type
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * Replace destination extents w/ attached data.
       * </pre>
       *
       * <code>REPLACE = 0;</code>
       */
      REPLACE(0),
      /**
       * <pre>
       * Replace destination extents w/ attached bzipped data.
       * </pre>
       *
       * <code>REPLACE_BZ = 1;</code>
       */
      REPLACE_BZ(1),
      /**
       * <pre>
       * Move source extents to target extents.
       * </pre>
       *
       * <code>MOVE = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated
      MOVE(2),
      /**
       * <pre>
       * The data is a bsdiff binary diff.
       * </pre>
       *
       * <code>BSDIFF = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated
      BSDIFF(3),
      /**
       * <pre>
       * On minor version 2 or newer, these operations are supported:
       * </pre>
       *
       * <code>SOURCE_COPY = 4;</code>
       */
      SOURCE_COPY(4),
      /**
       * <pre>
       * Like BSDIFF, but read from source partition
       * </pre>
       *
       * <code>SOURCE_BSDIFF = 5;</code>
       */
      SOURCE_BSDIFF(5),
      /**
       * <pre>
       * On minor version 3 or newer and on major version 2 or newer, these
       * operations are supported:
       * </pre>
       *
       * <code>REPLACE_XZ = 8;</code>
       */
      REPLACE_XZ(8),
      /**
       * <pre>
       * On minor version 4 or newer, these operations are supported:
       * </pre>
       *
       * <code>ZERO = 6;</code>
       */
      ZERO(6),
      /**
       * <pre>
       * Discard the destination blocks, reading as undefined.
       * </pre>
       *
       * <code>DISCARD = 7;</code>
       */
      DISCARD(7),
      /**
       * <pre>
       * Like SOURCE_BSDIFF, but compressed with brotli.
       * </pre>
       *
       * <code>BROTLI_BSDIFF = 10;</code>
       */
      BROTLI_BSDIFF(10),
      /**
       * <pre>
       * On minor version 5 or newer, these operations are supported:
       * </pre>
       *
       * <code>PUFFDIFF = 9;</code>
       */
      PUFFDIFF(9),
      /**
       * <pre>
       * On minor version 8 or newer, these operations are supported:
       * </pre>
       *
       * <code>ZUCCHINI = 11;</code>
       */
      ZUCCHINI(11),
      /**
       * <pre>
       * On minor version 9 or newer, these operations are supported:
       * </pre>
       *
       * <code>LZ4DIFF_BSDIFF = 12;</code>
       */
      LZ4DIFF_BSDIFF(12),
      /**
       * <code>LZ4DIFF_PUFFDIFF = 13;</code>
       */
      LZ4DIFF_PUFFDIFF(13),
      ;

      /**
       * <pre>
       * Replace destination extents w/ attached data.
       * </pre>
       *
       * <code>REPLACE = 0;</code>
       */
      public static final int REPLACE_VALUE = 0;
      /**
       * <pre>
       * Replace destination extents w/ attached bzipped data.
       * </pre>
       *
       * <code>REPLACE_BZ = 1;</code>
       */
      public static final int REPLACE_BZ_VALUE = 1;
      /**
       * <pre>
       * Move source extents to target extents.
       * </pre>
       *
       * <code>MOVE = 2 [deprecated = true];</code>
       */
      @java.lang.Deprecated public static final int MOVE_VALUE = 2;
      /**
       * <pre>
       * The data is a bsdiff binary diff.
       * </pre>
       *
       * <code>BSDIFF = 3 [deprecated = true];</code>
       */
      @java.lang.Deprecated public static final int BSDIFF_VALUE = 3;
      /**
       * <pre>
       * On minor version 2 or newer, these operations are supported:
       * </pre>
       *
       * <code>SOURCE_COPY = 4;</code>
       */
      public static final int SOURCE_COPY_VALUE = 4;
      /**
       * <pre>
       * Like BSDIFF, but read from source partition
       * </pre>
       *
       * <code>SOURCE_BSDIFF = 5;</code>
       */
      public static final int SOURCE_BSDIFF_VALUE = 5;
      /**
       * <pre>
       * On minor version 3 or newer and on major version 2 or newer, these
       * operations are supported:
       * </pre>
       *
       * <code>REPLACE_XZ = 8;</code>
       */
      public static final int REPLACE_XZ_VALUE = 8;
      /**
       * <pre>
       * On minor version 4 or newer, these operations are supported:
       * </pre>
       *
       * <code>ZERO = 6;</code>
       */
      public static final int ZERO_VALUE = 6;
      /**
       * <pre>
       * Discard the destination blocks, reading as undefined.
       * </pre>
       *
       * <code>DISCARD = 7;</code>
       */
      public static final int DISCARD_VALUE = 7;
      /**
       * <pre>
       * Like SOURCE_BSDIFF, but compressed with brotli.
       * </pre>
       *
       * <code>BROTLI_BSDIFF = 10;</code>
       */
      public static final int BROTLI_BSDIFF_VALUE = 10;
      /**
       * <pre>
       * On minor version 5 or newer, these operations are supported:
       * </pre>
       *
       * <code>PUFFDIFF = 9;</code>
       */
      public static final int PUFFDIFF_VALUE = 9;
      /**
       * <pre>
       * On minor version 8 or newer, these operations are supported:
       * </pre>
       *
       * <code>ZUCCHINI = 11;</code>
       */
      public static final int ZUCCHINI_VALUE = 11;
      /**
       * <pre>
       * On minor version 9 or newer, these operations are supported:
       * </pre>
       *
       * <code>LZ4DIFF_BSDIFF = 12;</code>
       */
      public static final int LZ4DIFF_BSDIFF_VALUE = 12;
      /**
       * <code>LZ4DIFF_PUFFDIFF = 13;</code>
       */
      public static final int LZ4DIFF_PUFFDIFF_VALUE = 13;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Type valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static Type forNumber(int value) {
        switch (value) {
          case 0: return REPLACE;
          case 1: return REPLACE_BZ;
          case 2: return MOVE;
          case 3: return BSDIFF;
          case 4: return SOURCE_COPY;
          case 5: return SOURCE_BSDIFF;
          case 8: return REPLACE_XZ;
          case 6: return ZERO;
          case 7: return DISCARD;
          case 10: return BROTLI_BSDIFF;
          case 9: return PUFFDIFF;
          case 11: return ZUCCHINI;
          case 12: return LZ4DIFF_BSDIFF;
          case 13: return LZ4DIFF_PUFFDIFF;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Type>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Type> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Type>() {
              public Type findValueByNumber(int number) {
                return Type.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.InstallOperation.getDescriptor().getEnumTypes().get(0);
      }

      private static final Type[] VALUES = values();

      public static Type valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Type(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:chromeos_update_engine.InstallOperation.Type)
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_ = 0;
    /**
     * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
     * @return The type.
     */
    @java.lang.Override public chromeos_update_engine.UpdateMetadata.InstallOperation.Type getType() {
      chromeos_update_engine.UpdateMetadata.InstallOperation.Type result = chromeos_update_engine.UpdateMetadata.InstallOperation.Type.forNumber(type_);
      return result == null ? chromeos_update_engine.UpdateMetadata.InstallOperation.Type.REPLACE : result;
    }

    public static final int DATA_OFFSET_FIELD_NUMBER = 2;
    private long dataOffset_ = 0L;
    /**
     * <pre>
     * Only minor version 6 or newer support 64 bits |data_offset| and
     * |data_length|, older client will read them as uint32.
     * The offset into the delta file (after the protobuf)
     * where the data (if any) is stored
     * </pre>
     *
     * <code>optional uint64 data_offset = 2;</code>
     * @return Whether the dataOffset field is set.
     */
    @java.lang.Override
    public boolean hasDataOffset() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Only minor version 6 or newer support 64 bits |data_offset| and
     * |data_length|, older client will read them as uint32.
     * The offset into the delta file (after the protobuf)
     * where the data (if any) is stored
     * </pre>
     *
     * <code>optional uint64 data_offset = 2;</code>
     * @return The dataOffset.
     */
    @java.lang.Override
    public long getDataOffset() {
      return dataOffset_;
    }

    public static final int DATA_LENGTH_FIELD_NUMBER = 3;
    private long dataLength_ = 0L;
    /**
     * <pre>
     * The length of the data in the delta file
     * </pre>
     *
     * <code>optional uint64 data_length = 3;</code>
     * @return Whether the dataLength field is set.
     */
    @java.lang.Override
    public boolean hasDataLength() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The length of the data in the delta file
     * </pre>
     *
     * <code>optional uint64 data_length = 3;</code>
     * @return The dataLength.
     */
    @java.lang.Override
    public long getDataLength() {
      return dataLength_;
    }

    public static final int SRC_EXTENTS_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private java.util.List<chromeos_update_engine.UpdateMetadata.Extent> srcExtents_;
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.Extent> getSrcExtentsList() {
      return srcExtents_;
    }
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> 
        getSrcExtentsOrBuilderList() {
      return srcExtents_;
    }
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    @java.lang.Override
    public int getSrcExtentsCount() {
      return srcExtents_.size();
    }
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getSrcExtents(int index) {
      return srcExtents_.get(index);
    }
    /**
     * <pre>
     * Ordered list of extents that are read from (if any) and written to.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getSrcExtentsOrBuilder(
        int index) {
      return srcExtents_.get(index);
    }

    public static final int SRC_LENGTH_FIELD_NUMBER = 5;
    private long srcLength_ = 0L;
    /**
     * <pre>
     * Byte length of src, equal to the number of blocks in src_extents *
     * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
     * pass that external program the number of bytes to read from the blocks we
     * pass it.  This is not used in any other operation.
     * </pre>
     *
     * <code>optional uint64 src_length = 5;</code>
     * @return Whether the srcLength field is set.
     */
    @java.lang.Override
    public boolean hasSrcLength() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Byte length of src, equal to the number of blocks in src_extents *
     * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
     * pass that external program the number of bytes to read from the blocks we
     * pass it.  This is not used in any other operation.
     * </pre>
     *
     * <code>optional uint64 src_length = 5;</code>
     * @return The srcLength.
     */
    @java.lang.Override
    public long getSrcLength() {
      return srcLength_;
    }

    public static final int DST_EXTENTS_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private java.util.List<chromeos_update_engine.UpdateMetadata.Extent> dstExtents_;
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.Extent> getDstExtentsList() {
      return dstExtents_;
    }
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> 
        getDstExtentsOrBuilderList() {
      return dstExtents_;
    }
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    @java.lang.Override
    public int getDstExtentsCount() {
      return dstExtents_.size();
    }
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getDstExtents(int index) {
      return dstExtents_.get(index);
    }
    /**
     * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getDstExtentsOrBuilder(
        int index) {
      return dstExtents_.get(index);
    }

    public static final int DST_LENGTH_FIELD_NUMBER = 7;
    private long dstLength_ = 0L;
    /**
     * <pre>
     * Byte length of dst, equal to the number of blocks in dst_extents *
     * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
     * operation.
     * </pre>
     *
     * <code>optional uint64 dst_length = 7;</code>
     * @return Whether the dstLength field is set.
     */
    @java.lang.Override
    public boolean hasDstLength() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Byte length of dst, equal to the number of blocks in dst_extents *
     * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
     * operation.
     * </pre>
     *
     * <code>optional uint64 dst_length = 7;</code>
     * @return The dstLength.
     */
    @java.lang.Override
    public long getDstLength() {
      return dstLength_;
    }

    public static final int DATA_SHA256_HASH_FIELD_NUMBER = 8;
    private com.google.protobuf.ByteString dataSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Optional SHA 256 hash of the blob associated with this operation.
     * This is used as a primary validation for http-based downloads and
     * as a defense-in-depth validation for https-based downloads. If
     * the operation doesn't refer to any blob, this field will have
     * zero bytes.
     * </pre>
     *
     * <code>optional bytes data_sha256_hash = 8;</code>
     * @return Whether the dataSha256Hash field is set.
     */
    @java.lang.Override
    public boolean hasDataSha256Hash() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Optional SHA 256 hash of the blob associated with this operation.
     * This is used as a primary validation for http-based downloads and
     * as a defense-in-depth validation for https-based downloads. If
     * the operation doesn't refer to any blob, this field will have
     * zero bytes.
     * </pre>
     *
     * <code>optional bytes data_sha256_hash = 8;</code>
     * @return The dataSha256Hash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getDataSha256Hash() {
      return dataSha256Hash_;
    }

    public static final int SRC_SHA256_HASH_FIELD_NUMBER = 9;
    private com.google.protobuf.ByteString srcSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * Indicates the SHA 256 hash of the source data referenced in src_extents at
     * the time of applying the operation. If present, the update_engine daemon
     * MUST read and verify the source data before applying the operation.
     * </pre>
     *
     * <code>optional bytes src_sha256_hash = 9;</code>
     * @return Whether the srcSha256Hash field is set.
     */
    @java.lang.Override
    public boolean hasSrcSha256Hash() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Indicates the SHA 256 hash of the source data referenced in src_extents at
     * the time of applying the operation. If present, the update_engine daemon
     * MUST read and verify the source data before applying the operation.
     * </pre>
     *
     * <code>optional bytes src_sha256_hash = 9;</code>
     * @return The srcSha256Hash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSrcSha256Hash() {
      return srcSha256Hash_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasType()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(2, dataOffset_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt64(3, dataLength_);
      }
      for (int i = 0; i < srcExtents_.size(); i++) {
        output.writeMessage(4, srcExtents_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt64(5, srcLength_);
      }
      for (int i = 0; i < dstExtents_.size(); i++) {
        output.writeMessage(6, dstExtents_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeUInt64(7, dstLength_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBytes(8, dataSha256Hash_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBytes(9, srcSha256Hash_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, dataOffset_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, dataLength_);
      }
      for (int i = 0; i < srcExtents_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, srcExtents_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(5, srcLength_);
      }
      for (int i = 0; i < dstExtents_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, dstExtents_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(7, dstLength_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(8, dataSha256Hash_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(9, srcSha256Hash_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.InstallOperation)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.InstallOperation other = (chromeos_update_engine.UpdateMetadata.InstallOperation) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (type_ != other.type_) return false;
      }
      if (hasDataOffset() != other.hasDataOffset()) return false;
      if (hasDataOffset()) {
        if (getDataOffset()
            != other.getDataOffset()) return false;
      }
      if (hasDataLength() != other.hasDataLength()) return false;
      if (hasDataLength()) {
        if (getDataLength()
            != other.getDataLength()) return false;
      }
      if (!getSrcExtentsList()
          .equals(other.getSrcExtentsList())) return false;
      if (hasSrcLength() != other.hasSrcLength()) return false;
      if (hasSrcLength()) {
        if (getSrcLength()
            != other.getSrcLength()) return false;
      }
      if (!getDstExtentsList()
          .equals(other.getDstExtentsList())) return false;
      if (hasDstLength() != other.hasDstLength()) return false;
      if (hasDstLength()) {
        if (getDstLength()
            != other.getDstLength()) return false;
      }
      if (hasDataSha256Hash() != other.hasDataSha256Hash()) return false;
      if (hasDataSha256Hash()) {
        if (!getDataSha256Hash()
            .equals(other.getDataSha256Hash())) return false;
      }
      if (hasSrcSha256Hash() != other.hasSrcSha256Hash()) return false;
      if (hasSrcSha256Hash()) {
        if (!getSrcSha256Hash()
            .equals(other.getSrcSha256Hash())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
      }
      if (hasDataOffset()) {
        hash = (37 * hash) + DATA_OFFSET_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDataOffset());
      }
      if (hasDataLength()) {
        hash = (37 * hash) + DATA_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDataLength());
      }
      if (getSrcExtentsCount() > 0) {
        hash = (37 * hash) + SRC_EXTENTS_FIELD_NUMBER;
        hash = (53 * hash) + getSrcExtentsList().hashCode();
      }
      if (hasSrcLength()) {
        hash = (37 * hash) + SRC_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSrcLength());
      }
      if (getDstExtentsCount() > 0) {
        hash = (37 * hash) + DST_EXTENTS_FIELD_NUMBER;
        hash = (53 * hash) + getDstExtentsList().hashCode();
      }
      if (hasDstLength()) {
        hash = (37 * hash) + DST_LENGTH_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDstLength());
      }
      if (hasDataSha256Hash()) {
        hash = (37 * hash) + DATA_SHA256_HASH_FIELD_NUMBER;
        hash = (53 * hash) + getDataSha256Hash().hashCode();
      }
      if (hasSrcSha256Hash()) {
        hash = (37 * hash) + SRC_SHA256_HASH_FIELD_NUMBER;
        hash = (53 * hash) + getSrcSha256Hash().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.InstallOperation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.InstallOperation prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chromeos_update_engine.InstallOperation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.InstallOperation)
        chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.InstallOperation.class, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.InstallOperation.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = 0;
        dataOffset_ = 0L;
        dataLength_ = 0L;
        if (srcExtentsBuilder_ == null) {
          srcExtents_ = java.util.Collections.emptyList();
        } else {
          srcExtents_ = null;
          srcExtentsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000008);
        srcLength_ = 0L;
        if (dstExtentsBuilder_ == null) {
          dstExtents_ = java.util.Collections.emptyList();
        } else {
          dstExtents_ = null;
          dstExtentsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000020);
        dstLength_ = 0L;
        dataSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
        srcSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_InstallOperation_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.InstallOperation getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.InstallOperation.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.InstallOperation build() {
        chromeos_update_engine.UpdateMetadata.InstallOperation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.InstallOperation buildPartial() {
        chromeos_update_engine.UpdateMetadata.InstallOperation result = new chromeos_update_engine.UpdateMetadata.InstallOperation(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(chromeos_update_engine.UpdateMetadata.InstallOperation result) {
        if (srcExtentsBuilder_ == null) {
          if (((bitField0_ & 0x00000008) != 0)) {
            srcExtents_ = java.util.Collections.unmodifiableList(srcExtents_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.srcExtents_ = srcExtents_;
        } else {
          result.srcExtents_ = srcExtentsBuilder_.build();
        }
        if (dstExtentsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0)) {
            dstExtents_ = java.util.Collections.unmodifiableList(dstExtents_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.dstExtents_ = dstExtents_;
        } else {
          result.dstExtents_ = dstExtentsBuilder_.build();
        }
      }

      private void buildPartial0(chromeos_update_engine.UpdateMetadata.InstallOperation result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.dataOffset_ = dataOffset_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.dataLength_ = dataLength_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.srcLength_ = srcLength_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.dstLength_ = dstLength_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.dataSha256Hash_ = dataSha256Hash_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.srcSha256Hash_ = srcSha256Hash_;
          to_bitField0_ |= 0x00000040;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.InstallOperation) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.InstallOperation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.InstallOperation other) {
        if (other == chromeos_update_engine.UpdateMetadata.InstallOperation.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasDataOffset()) {
          setDataOffset(other.getDataOffset());
        }
        if (other.hasDataLength()) {
          setDataLength(other.getDataLength());
        }
        if (srcExtentsBuilder_ == null) {
          if (!other.srcExtents_.isEmpty()) {
            if (srcExtents_.isEmpty()) {
              srcExtents_ = other.srcExtents_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureSrcExtentsIsMutable();
              srcExtents_.addAll(other.srcExtents_);
            }
            onChanged();
          }
        } else {
          if (!other.srcExtents_.isEmpty()) {
            if (srcExtentsBuilder_.isEmpty()) {
              srcExtentsBuilder_.dispose();
              srcExtentsBuilder_ = null;
              srcExtents_ = other.srcExtents_;
              bitField0_ = (bitField0_ & ~0x00000008);
              srcExtentsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getSrcExtentsFieldBuilder() : null;
            } else {
              srcExtentsBuilder_.addAllMessages(other.srcExtents_);
            }
          }
        }
        if (other.hasSrcLength()) {
          setSrcLength(other.getSrcLength());
        }
        if (dstExtentsBuilder_ == null) {
          if (!other.dstExtents_.isEmpty()) {
            if (dstExtents_.isEmpty()) {
              dstExtents_ = other.dstExtents_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensureDstExtentsIsMutable();
              dstExtents_.addAll(other.dstExtents_);
            }
            onChanged();
          }
        } else {
          if (!other.dstExtents_.isEmpty()) {
            if (dstExtentsBuilder_.isEmpty()) {
              dstExtentsBuilder_.dispose();
              dstExtentsBuilder_ = null;
              dstExtents_ = other.dstExtents_;
              bitField0_ = (bitField0_ & ~0x00000020);
              dstExtentsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getDstExtentsFieldBuilder() : null;
            } else {
              dstExtentsBuilder_.addAllMessages(other.dstExtents_);
            }
          }
        }
        if (other.hasDstLength()) {
          setDstLength(other.getDstLength());
        }
        if (other.hasDataSha256Hash()) {
          setDataSha256Hash(other.getDataSha256Hash());
        }
        if (other.hasSrcSha256Hash()) {
          setSrcSha256Hash(other.getSrcSha256Hash());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasType()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int tmpRaw = input.readEnum();
                chromeos_update_engine.UpdateMetadata.InstallOperation.Type tmpValue =
                    chromeos_update_engine.UpdateMetadata.InstallOperation.Type.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(1, tmpRaw);
                } else {
                  type_ = tmpRaw;
                  bitField0_ |= 0x00000001;
                }
                break;
              } // case 8
              case 16: {
                dataOffset_ = input.readUInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                dataLength_ = input.readUInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 34: {
                chromeos_update_engine.UpdateMetadata.Extent m =
                    input.readMessage(
                        chromeos_update_engine.UpdateMetadata.Extent.PARSER,
                        extensionRegistry);
                if (srcExtentsBuilder_ == null) {
                  ensureSrcExtentsIsMutable();
                  srcExtents_.add(m);
                } else {
                  srcExtentsBuilder_.addMessage(m);
                }
                break;
              } // case 34
              case 40: {
                srcLength_ = input.readUInt64();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 50: {
                chromeos_update_engine.UpdateMetadata.Extent m =
                    input.readMessage(
                        chromeos_update_engine.UpdateMetadata.Extent.PARSER,
                        extensionRegistry);
                if (dstExtentsBuilder_ == null) {
                  ensureDstExtentsIsMutable();
                  dstExtents_.add(m);
                } else {
                  dstExtentsBuilder_.addMessage(m);
                }
                break;
              } // case 50
              case 56: {
                dstLength_ = input.readUInt64();
                bitField0_ |= 0x00000040;
                break;
              } // case 56
              case 66: {
                dataSha256Hash_ = input.readBytes();
                bitField0_ |= 0x00000080;
                break;
              } // case 66
              case 74: {
                srcSha256Hash_ = input.readBytes();
                bitField0_ |= 0x00000100;
                break;
              } // case 74
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int type_ = 0;
      /**
       * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.InstallOperation.Type getType() {
        chromeos_update_engine.UpdateMetadata.InstallOperation.Type result = chromeos_update_engine.UpdateMetadata.InstallOperation.Type.forNumber(type_);
        return result == null ? chromeos_update_engine.UpdateMetadata.InstallOperation.Type.REPLACE : result;
      }
      /**
       * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(chromeos_update_engine.UpdateMetadata.InstallOperation.Type value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>required .chromeos_update_engine.InstallOperation.Type type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 0;
        onChanged();
        return this;
      }

      private long dataOffset_ ;
      /**
       * <pre>
       * Only minor version 6 or newer support 64 bits |data_offset| and
       * |data_length|, older client will read them as uint32.
       * The offset into the delta file (after the protobuf)
       * where the data (if any) is stored
       * </pre>
       *
       * <code>optional uint64 data_offset = 2;</code>
       * @return Whether the dataOffset field is set.
       */
      @java.lang.Override
      public boolean hasDataOffset() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Only minor version 6 or newer support 64 bits |data_offset| and
       * |data_length|, older client will read them as uint32.
       * The offset into the delta file (after the protobuf)
       * where the data (if any) is stored
       * </pre>
       *
       * <code>optional uint64 data_offset = 2;</code>
       * @return The dataOffset.
       */
      @java.lang.Override
      public long getDataOffset() {
        return dataOffset_;
      }
      /**
       * <pre>
       * Only minor version 6 or newer support 64 bits |data_offset| and
       * |data_length|, older client will read them as uint32.
       * The offset into the delta file (after the protobuf)
       * where the data (if any) is stored
       * </pre>
       *
       * <code>optional uint64 data_offset = 2;</code>
       * @param value The dataOffset to set.
       * @return This builder for chaining.
       */
      public Builder setDataOffset(long value) {
        
        dataOffset_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Only minor version 6 or newer support 64 bits |data_offset| and
       * |data_length|, older client will read them as uint32.
       * The offset into the delta file (after the protobuf)
       * where the data (if any) is stored
       * </pre>
       *
       * <code>optional uint64 data_offset = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataOffset() {
        bitField0_ = (bitField0_ & ~0x00000002);
        dataOffset_ = 0L;
        onChanged();
        return this;
      }

      private long dataLength_ ;
      /**
       * <pre>
       * The length of the data in the delta file
       * </pre>
       *
       * <code>optional uint64 data_length = 3;</code>
       * @return Whether the dataLength field is set.
       */
      @java.lang.Override
      public boolean hasDataLength() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The length of the data in the delta file
       * </pre>
       *
       * <code>optional uint64 data_length = 3;</code>
       * @return The dataLength.
       */
      @java.lang.Override
      public long getDataLength() {
        return dataLength_;
      }
      /**
       * <pre>
       * The length of the data in the delta file
       * </pre>
       *
       * <code>optional uint64 data_length = 3;</code>
       * @param value The dataLength to set.
       * @return This builder for chaining.
       */
      public Builder setDataLength(long value) {
        
        dataLength_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The length of the data in the delta file
       * </pre>
       *
       * <code>optional uint64 data_length = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataLength() {
        bitField0_ = (bitField0_ & ~0x00000004);
        dataLength_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<chromeos_update_engine.UpdateMetadata.Extent> srcExtents_ =
        java.util.Collections.emptyList();
      private void ensureSrcExtentsIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          srcExtents_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.Extent>(srcExtents_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> srcExtentsBuilder_;

      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Extent> getSrcExtentsList() {
        if (srcExtentsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(srcExtents_);
        } else {
          return srcExtentsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public int getSrcExtentsCount() {
        if (srcExtentsBuilder_ == null) {
          return srcExtents_.size();
        } else {
          return srcExtentsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent getSrcExtents(int index) {
        if (srcExtentsBuilder_ == null) {
          return srcExtents_.get(index);
        } else {
          return srcExtentsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder setSrcExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent value) {
        if (srcExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSrcExtentsIsMutable();
          srcExtents_.set(index, value);
          onChanged();
        } else {
          srcExtentsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder setSrcExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          srcExtents_.set(index, builderForValue.build());
          onChanged();
        } else {
          srcExtentsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder addSrcExtents(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (srcExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSrcExtentsIsMutable();
          srcExtents_.add(value);
          onChanged();
        } else {
          srcExtentsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder addSrcExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent value) {
        if (srcExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureSrcExtentsIsMutable();
          srcExtents_.add(index, value);
          onChanged();
        } else {
          srcExtentsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder addSrcExtents(
          chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          srcExtents_.add(builderForValue.build());
          onChanged();
        } else {
          srcExtentsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder addSrcExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          srcExtents_.add(index, builderForValue.build());
          onChanged();
        } else {
          srcExtentsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder addAllSrcExtents(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.Extent> values) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, srcExtents_);
          onChanged();
        } else {
          srcExtentsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder clearSrcExtents() {
        if (srcExtentsBuilder_ == null) {
          srcExtents_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          srcExtentsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public Builder removeSrcExtents(int index) {
        if (srcExtentsBuilder_ == null) {
          ensureSrcExtentsIsMutable();
          srcExtents_.remove(index);
          onChanged();
        } else {
          srcExtentsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder getSrcExtentsBuilder(
          int index) {
        return getSrcExtentsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getSrcExtentsOrBuilder(
          int index) {
        if (srcExtentsBuilder_ == null) {
          return srcExtents_.get(index);  } else {
          return srcExtentsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> 
           getSrcExtentsOrBuilderList() {
        if (srcExtentsBuilder_ != null) {
          return srcExtentsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(srcExtents_);
        }
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder addSrcExtentsBuilder() {
        return getSrcExtentsFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance());
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder addSrcExtentsBuilder(
          int index) {
        return getSrcExtentsFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance());
      }
      /**
       * <pre>
       * Ordered list of extents that are read from (if any) and written to.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Extent src_extents = 4;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Extent.Builder> 
           getSrcExtentsBuilderList() {
        return getSrcExtentsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> 
          getSrcExtentsFieldBuilder() {
        if (srcExtentsBuilder_ == null) {
          srcExtentsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>(
                  srcExtents_,
                  ((bitField0_ & 0x00000008) != 0),
                  getParentForChildren(),
                  isClean());
          srcExtents_ = null;
        }
        return srcExtentsBuilder_;
      }

      private long srcLength_ ;
      /**
       * <pre>
       * Byte length of src, equal to the number of blocks in src_extents *
       * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
       * pass that external program the number of bytes to read from the blocks we
       * pass it.  This is not used in any other operation.
       * </pre>
       *
       * <code>optional uint64 src_length = 5;</code>
       * @return Whether the srcLength field is set.
       */
      @java.lang.Override
      public boolean hasSrcLength() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Byte length of src, equal to the number of blocks in src_extents *
       * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
       * pass that external program the number of bytes to read from the blocks we
       * pass it.  This is not used in any other operation.
       * </pre>
       *
       * <code>optional uint64 src_length = 5;</code>
       * @return The srcLength.
       */
      @java.lang.Override
      public long getSrcLength() {
        return srcLength_;
      }
      /**
       * <pre>
       * Byte length of src, equal to the number of blocks in src_extents *
       * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
       * pass that external program the number of bytes to read from the blocks we
       * pass it.  This is not used in any other operation.
       * </pre>
       *
       * <code>optional uint64 src_length = 5;</code>
       * @param value The srcLength to set.
       * @return This builder for chaining.
       */
      public Builder setSrcLength(long value) {
        
        srcLength_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Byte length of src, equal to the number of blocks in src_extents *
       * block_size. It is used for BSDIFF and SOURCE_BSDIFF, because we need to
       * pass that external program the number of bytes to read from the blocks we
       * pass it.  This is not used in any other operation.
       * </pre>
       *
       * <code>optional uint64 src_length = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSrcLength() {
        bitField0_ = (bitField0_ & ~0x00000010);
        srcLength_ = 0L;
        onChanged();
        return this;
      }

      private java.util.List<chromeos_update_engine.UpdateMetadata.Extent> dstExtents_ =
        java.util.Collections.emptyList();
      private void ensureDstExtentsIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          dstExtents_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.Extent>(dstExtents_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> dstExtentsBuilder_;

      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Extent> getDstExtentsList() {
        if (dstExtentsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(dstExtents_);
        } else {
          return dstExtentsBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public int getDstExtentsCount() {
        if (dstExtentsBuilder_ == null) {
          return dstExtents_.size();
        } else {
          return dstExtentsBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent getDstExtents(int index) {
        if (dstExtentsBuilder_ == null) {
          return dstExtents_.get(index);
        } else {
          return dstExtentsBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder setDstExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent value) {
        if (dstExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDstExtentsIsMutable();
          dstExtents_.set(index, value);
          onChanged();
        } else {
          dstExtentsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder setDstExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          dstExtents_.set(index, builderForValue.build());
          onChanged();
        } else {
          dstExtentsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder addDstExtents(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (dstExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDstExtentsIsMutable();
          dstExtents_.add(value);
          onChanged();
        } else {
          dstExtentsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder addDstExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent value) {
        if (dstExtentsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureDstExtentsIsMutable();
          dstExtents_.add(index, value);
          onChanged();
        } else {
          dstExtentsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder addDstExtents(
          chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          dstExtents_.add(builderForValue.build());
          onChanged();
        } else {
          dstExtentsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder addDstExtents(
          int index, chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          dstExtents_.add(index, builderForValue.build());
          onChanged();
        } else {
          dstExtentsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder addAllDstExtents(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.Extent> values) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, dstExtents_);
          onChanged();
        } else {
          dstExtentsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder clearDstExtents() {
        if (dstExtentsBuilder_ == null) {
          dstExtents_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          dstExtentsBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public Builder removeDstExtents(int index) {
        if (dstExtentsBuilder_ == null) {
          ensureDstExtentsIsMutable();
          dstExtents_.remove(index);
          onChanged();
        } else {
          dstExtentsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder getDstExtentsBuilder(
          int index) {
        return getDstExtentsFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getDstExtentsOrBuilder(
          int index) {
        if (dstExtentsBuilder_ == null) {
          return dstExtents_.get(index);  } else {
          return dstExtentsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> 
           getDstExtentsOrBuilderList() {
        if (dstExtentsBuilder_ != null) {
          return dstExtentsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(dstExtents_);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder addDstExtentsBuilder() {
        return getDstExtentsFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance());
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder addDstExtentsBuilder(
          int index) {
        return getDstExtentsFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance());
      }
      /**
       * <code>repeated .chromeos_update_engine.Extent dst_extents = 6;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Extent.Builder> 
           getDstExtentsBuilderList() {
        return getDstExtentsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> 
          getDstExtentsFieldBuilder() {
        if (dstExtentsBuilder_ == null) {
          dstExtentsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>(
                  dstExtents_,
                  ((bitField0_ & 0x00000020) != 0),
                  getParentForChildren(),
                  isClean());
          dstExtents_ = null;
        }
        return dstExtentsBuilder_;
      }

      private long dstLength_ ;
      /**
       * <pre>
       * Byte length of dst, equal to the number of blocks in dst_extents *
       * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
       * operation.
       * </pre>
       *
       * <code>optional uint64 dst_length = 7;</code>
       * @return Whether the dstLength field is set.
       */
      @java.lang.Override
      public boolean hasDstLength() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Byte length of dst, equal to the number of blocks in dst_extents *
       * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
       * operation.
       * </pre>
       *
       * <code>optional uint64 dst_length = 7;</code>
       * @return The dstLength.
       */
      @java.lang.Override
      public long getDstLength() {
        return dstLength_;
      }
      /**
       * <pre>
       * Byte length of dst, equal to the number of blocks in dst_extents *
       * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
       * operation.
       * </pre>
       *
       * <code>optional uint64 dst_length = 7;</code>
       * @param value The dstLength to set.
       * @return This builder for chaining.
       */
      public Builder setDstLength(long value) {
        
        dstLength_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Byte length of dst, equal to the number of blocks in dst_extents *
       * block_size. Used for BSDIFF and SOURCE_BSDIFF, but not in any other
       * operation.
       * </pre>
       *
       * <code>optional uint64 dst_length = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearDstLength() {
        bitField0_ = (bitField0_ & ~0x00000040);
        dstLength_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString dataSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Optional SHA 256 hash of the blob associated with this operation.
       * This is used as a primary validation for http-based downloads and
       * as a defense-in-depth validation for https-based downloads. If
       * the operation doesn't refer to any blob, this field will have
       * zero bytes.
       * </pre>
       *
       * <code>optional bytes data_sha256_hash = 8;</code>
       * @return Whether the dataSha256Hash field is set.
       */
      @java.lang.Override
      public boolean hasDataSha256Hash() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Optional SHA 256 hash of the blob associated with this operation.
       * This is used as a primary validation for http-based downloads and
       * as a defense-in-depth validation for https-based downloads. If
       * the operation doesn't refer to any blob, this field will have
       * zero bytes.
       * </pre>
       *
       * <code>optional bytes data_sha256_hash = 8;</code>
       * @return The dataSha256Hash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getDataSha256Hash() {
        return dataSha256Hash_;
      }
      /**
       * <pre>
       * Optional SHA 256 hash of the blob associated with this operation.
       * This is used as a primary validation for http-based downloads and
       * as a defense-in-depth validation for https-based downloads. If
       * the operation doesn't refer to any blob, this field will have
       * zero bytes.
       * </pre>
       *
       * <code>optional bytes data_sha256_hash = 8;</code>
       * @param value The dataSha256Hash to set.
       * @return This builder for chaining.
       */
      public Builder setDataSha256Hash(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        dataSha256Hash_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional SHA 256 hash of the blob associated with this operation.
       * This is used as a primary validation for http-based downloads and
       * as a defense-in-depth validation for https-based downloads. If
       * the operation doesn't refer to any blob, this field will have
       * zero bytes.
       * </pre>
       *
       * <code>optional bytes data_sha256_hash = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataSha256Hash() {
        bitField0_ = (bitField0_ & ~0x00000080);
        dataSha256Hash_ = getDefaultInstance().getDataSha256Hash();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString srcSha256Hash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Indicates the SHA 256 hash of the source data referenced in src_extents at
       * the time of applying the operation. If present, the update_engine daemon
       * MUST read and verify the source data before applying the operation.
       * </pre>
       *
       * <code>optional bytes src_sha256_hash = 9;</code>
       * @return Whether the srcSha256Hash field is set.
       */
      @java.lang.Override
      public boolean hasSrcSha256Hash() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Indicates the SHA 256 hash of the source data referenced in src_extents at
       * the time of applying the operation. If present, the update_engine daemon
       * MUST read and verify the source data before applying the operation.
       * </pre>
       *
       * <code>optional bytes src_sha256_hash = 9;</code>
       * @return The srcSha256Hash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSrcSha256Hash() {
        return srcSha256Hash_;
      }
      /**
       * <pre>
       * Indicates the SHA 256 hash of the source data referenced in src_extents at
       * the time of applying the operation. If present, the update_engine daemon
       * MUST read and verify the source data before applying the operation.
       * </pre>
       *
       * <code>optional bytes src_sha256_hash = 9;</code>
       * @param value The srcSha256Hash to set.
       * @return This builder for chaining.
       */
      public Builder setSrcSha256Hash(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        srcSha256Hash_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Indicates the SHA 256 hash of the source data referenced in src_extents at
       * the time of applying the operation. If present, the update_engine daemon
       * MUST read and verify the source data before applying the operation.
       * </pre>
       *
       * <code>optional bytes src_sha256_hash = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearSrcSha256Hash() {
        bitField0_ = (bitField0_ & ~0x00000100);
        srcSha256Hash_ = getDefaultInstance().getSrcSha256Hash();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.InstallOperation)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.InstallOperation)
    private static final chromeos_update_engine.UpdateMetadata.InstallOperation DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.InstallOperation();
    }

    public static chromeos_update_engine.UpdateMetadata.InstallOperation getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<InstallOperation>
        PARSER = new com.google.protobuf.AbstractParser<InstallOperation>() {
      @java.lang.Override
      public InstallOperation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<InstallOperation> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<InstallOperation> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.InstallOperation getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface CowMergeOperationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.CowMergeOperation)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional .chromeos_update_engine.CowMergeOperation.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <code>optional .chromeos_update_engine.CowMergeOperation.Type type = 1;</code>
     * @return The type.
     */
    chromeos_update_engine.UpdateMetadata.CowMergeOperation.Type getType();

    /**
     * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
     * @return Whether the srcExtent field is set.
     */
    boolean hasSrcExtent();
    /**
     * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
     * @return The srcExtent.
     */
    chromeos_update_engine.UpdateMetadata.Extent getSrcExtent();
    /**
     * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
     */
    chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getSrcExtentOrBuilder();

    /**
     * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
     * @return Whether the dstExtent field is set.
     */
    boolean hasDstExtent();
    /**
     * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
     * @return The dstExtent.
     */
    chromeos_update_engine.UpdateMetadata.Extent getDstExtent();
    /**
     * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
     */
    chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getDstExtentOrBuilder();

    /**
     * <pre>
     * For COW_XOR, source location might be unaligned, so this field is in range
     * [0, block_size), representing how much should the src_extent shift toward
     * larger block number. If this field is non-zero, then src_extent will
     * include 1 extra block in the end, as the merge op actually references the
     * first |src_offset| bytes of that extra block. For example, if |dst_extent|
     * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
     * Note that |src_extent| contains 1 extra block than the |dst_extent|.
     * </pre>
     *
     * <code>optional uint32 src_offset = 4;</code>
     * @return Whether the srcOffset field is set.
     */
    boolean hasSrcOffset();
    /**
     * <pre>
     * For COW_XOR, source location might be unaligned, so this field is in range
     * [0, block_size), representing how much should the src_extent shift toward
     * larger block number. If this field is non-zero, then src_extent will
     * include 1 extra block in the end, as the merge op actually references the
     * first |src_offset| bytes of that extra block. For example, if |dst_extent|
     * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
     * Note that |src_extent| contains 1 extra block than the |dst_extent|.
     * </pre>
     *
     * <code>optional uint32 src_offset = 4;</code>
     * @return The srcOffset.
     */
    int getSrcOffset();
  }
  /**
   * <pre>
   * Hints to VAB snapshot to skip writing some blocks if these blocks are
   * identical to the ones on the source image. The src &amp; dst extents for each
   * CowMergeOperation should be contiguous, and they're a subset of an OTA
   * InstallOperation.
   * During merge time, we need to follow the pre-computed sequence to avoid
   * read after write, similar to the inplace update schema.
   * </pre>
   *
   * Protobuf type {@code chromeos_update_engine.CowMergeOperation}
   */
  public static final class CowMergeOperation extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.CowMergeOperation)
      CowMergeOperationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use CowMergeOperation.newBuilder() to construct.
    private CowMergeOperation(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private CowMergeOperation() {
      type_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new CowMergeOperation();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_CowMergeOperation_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_CowMergeOperation_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.CowMergeOperation.class, chromeos_update_engine.UpdateMetadata.CowMergeOperation.Builder.class);
    }

    /**
     * Protobuf enum {@code chromeos_update_engine.CowMergeOperation.Type}
     */
    public enum Type
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <pre>
       * identical blocks
       * </pre>
       *
       * <code>COW_COPY = 0;</code>
       */
      COW_COPY(0),
      /**
       * <pre>
       * used when src/dst blocks are highly similar
       * </pre>
       *
       * <code>COW_XOR = 1;</code>
       */
      COW_XOR(1),
      /**
       * <pre>
       * Raw replace operation
       * </pre>
       *
       * <code>COW_REPLACE = 2;</code>
       */
      COW_REPLACE(2),
      ;

      /**
       * <pre>
       * identical blocks
       * </pre>
       *
       * <code>COW_COPY = 0;</code>
       */
      public static final int COW_COPY_VALUE = 0;
      /**
       * <pre>
       * used when src/dst blocks are highly similar
       * </pre>
       *
       * <code>COW_XOR = 1;</code>
       */
      public static final int COW_XOR_VALUE = 1;
      /**
       * <pre>
       * Raw replace operation
       * </pre>
       *
       * <code>COW_REPLACE = 2;</code>
       */
      public static final int COW_REPLACE_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Type valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static Type forNumber(int value) {
        switch (value) {
          case 0: return COW_COPY;
          case 1: return COW_XOR;
          case 2: return COW_REPLACE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Type>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Type> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Type>() {
              public Type findValueByNumber(int number) {
                return Type.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.CowMergeOperation.getDescriptor().getEnumTypes().get(0);
      }

      private static final Type[] VALUES = values();

      public static Type valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Type(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:chromeos_update_engine.CowMergeOperation.Type)
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_ = 0;
    /**
     * <code>optional .chromeos_update_engine.CowMergeOperation.Type type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .chromeos_update_engine.CowMergeOperation.Type type = 1;</code>
     * @return The type.
     */
    @java.lang.Override public chromeos_update_engine.UpdateMetadata.CowMergeOperation.Type getType() {
      chromeos_update_engine.UpdateMetadata.CowMergeOperation.Type result = chromeos_update_engine.UpdateMetadata.CowMergeOperation.Type.forNumber(type_);
      return result == null ? chromeos_update_engine.UpdateMetadata.CowMergeOperation.Type.COW_COPY : result;
    }

    public static final int SRC_EXTENT_FIELD_NUMBER = 2;
    private chromeos_update_engine.UpdateMetadata.Extent srcExtent_;
    /**
     * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
     * @return Whether the srcExtent field is set.
     */
    @java.lang.Override
    public boolean hasSrcExtent() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
     * @return The srcExtent.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getSrcExtent() {
      return srcExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : srcExtent_;
    }
    /**
     * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getSrcExtentOrBuilder() {
      return srcExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : srcExtent_;
    }

    public static final int DST_EXTENT_FIELD_NUMBER = 3;
    private chromeos_update_engine.UpdateMetadata.Extent dstExtent_;
    /**
     * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
     * @return Whether the dstExtent field is set.
     */
    @java.lang.Override
    public boolean hasDstExtent() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
     * @return The dstExtent.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getDstExtent() {
      return dstExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : dstExtent_;
    }
    /**
     * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getDstExtentOrBuilder() {
      return dstExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : dstExtent_;
    }

    public static final int SRC_OFFSET_FIELD_NUMBER = 4;
    private int srcOffset_ = 0;
    /**
     * <pre>
     * For COW_XOR, source location might be unaligned, so this field is in range
     * [0, block_size), representing how much should the src_extent shift toward
     * larger block number. If this field is non-zero, then src_extent will
     * include 1 extra block in the end, as the merge op actually references the
     * first |src_offset| bytes of that extra block. For example, if |dst_extent|
     * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
     * Note that |src_extent| contains 1 extra block than the |dst_extent|.
     * </pre>
     *
     * <code>optional uint32 src_offset = 4;</code>
     * @return Whether the srcOffset field is set.
     */
    @java.lang.Override
    public boolean hasSrcOffset() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * For COW_XOR, source location might be unaligned, so this field is in range
     * [0, block_size), representing how much should the src_extent shift toward
     * larger block number. If this field is non-zero, then src_extent will
     * include 1 extra block in the end, as the merge op actually references the
     * first |src_offset| bytes of that extra block. For example, if |dst_extent|
     * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
     * Note that |src_extent| contains 1 extra block than the |dst_extent|.
     * </pre>
     *
     * <code>optional uint32 src_offset = 4;</code>
     * @return The srcOffset.
     */
    @java.lang.Override
    public int getSrcOffset() {
      return srcOffset_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(2, getSrcExtent());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeMessage(3, getDstExtent());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt32(4, srcOffset_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSrcExtent());
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getDstExtent());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(4, srcOffset_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.CowMergeOperation)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.CowMergeOperation other = (chromeos_update_engine.UpdateMetadata.CowMergeOperation) obj;

      if (hasType() != other.hasType()) return false;
      if (hasType()) {
        if (type_ != other.type_) return false;
      }
      if (hasSrcExtent() != other.hasSrcExtent()) return false;
      if (hasSrcExtent()) {
        if (!getSrcExtent()
            .equals(other.getSrcExtent())) return false;
      }
      if (hasDstExtent() != other.hasDstExtent()) return false;
      if (hasDstExtent()) {
        if (!getDstExtent()
            .equals(other.getDstExtent())) return false;
      }
      if (hasSrcOffset() != other.hasSrcOffset()) return false;
      if (hasSrcOffset()) {
        if (getSrcOffset()
            != other.getSrcOffset()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + type_;
      }
      if (hasSrcExtent()) {
        hash = (37 * hash) + SRC_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getSrcExtent().hashCode();
      }
      if (hasDstExtent()) {
        hash = (37 * hash) + DST_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getDstExtent().hashCode();
      }
      if (hasSrcOffset()) {
        hash = (37 * hash) + SRC_OFFSET_FIELD_NUMBER;
        hash = (53 * hash) + getSrcOffset();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.CowMergeOperation parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.CowMergeOperation parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.CowMergeOperation parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.CowMergeOperation parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.CowMergeOperation parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.CowMergeOperation parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.CowMergeOperation parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.CowMergeOperation parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.CowMergeOperation parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.CowMergeOperation parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.CowMergeOperation parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.CowMergeOperation parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.CowMergeOperation prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Hints to VAB snapshot to skip writing some blocks if these blocks are
     * identical to the ones on the source image. The src &amp; dst extents for each
     * CowMergeOperation should be contiguous, and they're a subset of an OTA
     * InstallOperation.
     * During merge time, we need to follow the pre-computed sequence to avoid
     * read after write, similar to the inplace update schema.
     * </pre>
     *
     * Protobuf type {@code chromeos_update_engine.CowMergeOperation}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.CowMergeOperation)
        chromeos_update_engine.UpdateMetadata.CowMergeOperationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_CowMergeOperation_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_CowMergeOperation_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.CowMergeOperation.class, chromeos_update_engine.UpdateMetadata.CowMergeOperation.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.CowMergeOperation.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSrcExtentFieldBuilder();
          getDstExtentFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        type_ = 0;
        srcExtent_ = null;
        if (srcExtentBuilder_ != null) {
          srcExtentBuilder_.dispose();
          srcExtentBuilder_ = null;
        }
        dstExtent_ = null;
        if (dstExtentBuilder_ != null) {
          dstExtentBuilder_.dispose();
          dstExtentBuilder_ = null;
        }
        srcOffset_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_CowMergeOperation_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.CowMergeOperation getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.CowMergeOperation.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.CowMergeOperation build() {
        chromeos_update_engine.UpdateMetadata.CowMergeOperation result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.CowMergeOperation buildPartial() {
        chromeos_update_engine.UpdateMetadata.CowMergeOperation result = new chromeos_update_engine.UpdateMetadata.CowMergeOperation(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(chromeos_update_engine.UpdateMetadata.CowMergeOperation result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.type_ = type_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.srcExtent_ = srcExtentBuilder_ == null
              ? srcExtent_
              : srcExtentBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.dstExtent_ = dstExtentBuilder_ == null
              ? dstExtent_
              : dstExtentBuilder_.build();
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.srcOffset_ = srcOffset_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.CowMergeOperation) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.CowMergeOperation)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.CowMergeOperation other) {
        if (other == chromeos_update_engine.UpdateMetadata.CowMergeOperation.getDefaultInstance()) return this;
        if (other.hasType()) {
          setType(other.getType());
        }
        if (other.hasSrcExtent()) {
          mergeSrcExtent(other.getSrcExtent());
        }
        if (other.hasDstExtent()) {
          mergeDstExtent(other.getDstExtent());
        }
        if (other.hasSrcOffset()) {
          setSrcOffset(other.getSrcOffset());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int tmpRaw = input.readEnum();
                chromeos_update_engine.UpdateMetadata.CowMergeOperation.Type tmpValue =
                    chromeos_update_engine.UpdateMetadata.CowMergeOperation.Type.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(1, tmpRaw);
                } else {
                  type_ = tmpRaw;
                  bitField0_ |= 0x00000001;
                }
                break;
              } // case 8
              case 18: {
                input.readMessage(
                    getSrcExtentFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 18
              case 26: {
                input.readMessage(
                    getDstExtentFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 32: {
                srcOffset_ = input.readUInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int type_ = 0;
      /**
       * <code>optional .chromeos_update_engine.CowMergeOperation.Type type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override public boolean hasType() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional .chromeos_update_engine.CowMergeOperation.Type type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.CowMergeOperation.Type getType() {
        chromeos_update_engine.UpdateMetadata.CowMergeOperation.Type result = chromeos_update_engine.UpdateMetadata.CowMergeOperation.Type.forNumber(type_);
        return result == null ? chromeos_update_engine.UpdateMetadata.CowMergeOperation.Type.COW_COPY : result;
      }
      /**
       * <code>optional .chromeos_update_engine.CowMergeOperation.Type type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(chromeos_update_engine.UpdateMetadata.CowMergeOperation.Type value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.CowMergeOperation.Type type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = 0;
        onChanged();
        return this;
      }

      private chromeos_update_engine.UpdateMetadata.Extent srcExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> srcExtentBuilder_;
      /**
       * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
       * @return Whether the srcExtent field is set.
       */
      public boolean hasSrcExtent() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
       * @return The srcExtent.
       */
      public chromeos_update_engine.UpdateMetadata.Extent getSrcExtent() {
        if (srcExtentBuilder_ == null) {
          return srcExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : srcExtent_;
        } else {
          return srcExtentBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
       */
      public Builder setSrcExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (srcExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          srcExtent_ = value;
        } else {
          srcExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
       */
      public Builder setSrcExtent(
          chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (srcExtentBuilder_ == null) {
          srcExtent_ = builderForValue.build();
        } else {
          srcExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
       */
      public Builder mergeSrcExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (srcExtentBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            srcExtent_ != null &&
            srcExtent_ != chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance()) {
            getSrcExtentBuilder().mergeFrom(value);
          } else {
            srcExtent_ = value;
          }
        } else {
          srcExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
       */
      public Builder clearSrcExtent() {
        bitField0_ = (bitField0_ & ~0x00000002);
        srcExtent_ = null;
        if (srcExtentBuilder_ != null) {
          srcExtentBuilder_.dispose();
          srcExtentBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder getSrcExtentBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSrcExtentFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getSrcExtentOrBuilder() {
        if (srcExtentBuilder_ != null) {
          return srcExtentBuilder_.getMessageOrBuilder();
        } else {
          return srcExtent_ == null ?
              chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : srcExtent_;
        }
      }
      /**
       * <code>optional .chromeos_update_engine.Extent src_extent = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> 
          getSrcExtentFieldBuilder() {
        if (srcExtentBuilder_ == null) {
          srcExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>(
                  getSrcExtent(),
                  getParentForChildren(),
                  isClean());
          srcExtent_ = null;
        }
        return srcExtentBuilder_;
      }

      private chromeos_update_engine.UpdateMetadata.Extent dstExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> dstExtentBuilder_;
      /**
       * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
       * @return Whether the dstExtent field is set.
       */
      public boolean hasDstExtent() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
       * @return The dstExtent.
       */
      public chromeos_update_engine.UpdateMetadata.Extent getDstExtent() {
        if (dstExtentBuilder_ == null) {
          return dstExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : dstExtent_;
        } else {
          return dstExtentBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
       */
      public Builder setDstExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (dstExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          dstExtent_ = value;
        } else {
          dstExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
       */
      public Builder setDstExtent(
          chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (dstExtentBuilder_ == null) {
          dstExtent_ = builderForValue.build();
        } else {
          dstExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
       */
      public Builder mergeDstExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (dstExtentBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0) &&
            dstExtent_ != null &&
            dstExtent_ != chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance()) {
            getDstExtentBuilder().mergeFrom(value);
          } else {
            dstExtent_ = value;
          }
        } else {
          dstExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
       */
      public Builder clearDstExtent() {
        bitField0_ = (bitField0_ & ~0x00000004);
        dstExtent_ = null;
        if (dstExtentBuilder_ != null) {
          dstExtentBuilder_.dispose();
          dstExtentBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder getDstExtentBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getDstExtentFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getDstExtentOrBuilder() {
        if (dstExtentBuilder_ != null) {
          return dstExtentBuilder_.getMessageOrBuilder();
        } else {
          return dstExtent_ == null ?
              chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : dstExtent_;
        }
      }
      /**
       * <code>optional .chromeos_update_engine.Extent dst_extent = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> 
          getDstExtentFieldBuilder() {
        if (dstExtentBuilder_ == null) {
          dstExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>(
                  getDstExtent(),
                  getParentForChildren(),
                  isClean());
          dstExtent_ = null;
        }
        return dstExtentBuilder_;
      }

      private int srcOffset_ ;
      /**
       * <pre>
       * For COW_XOR, source location might be unaligned, so this field is in range
       * [0, block_size), representing how much should the src_extent shift toward
       * larger block number. If this field is non-zero, then src_extent will
       * include 1 extra block in the end, as the merge op actually references the
       * first |src_offset| bytes of that extra block. For example, if |dst_extent|
       * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
       * Note that |src_extent| contains 1 extra block than the |dst_extent|.
       * </pre>
       *
       * <code>optional uint32 src_offset = 4;</code>
       * @return Whether the srcOffset field is set.
       */
      @java.lang.Override
      public boolean hasSrcOffset() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * For COW_XOR, source location might be unaligned, so this field is in range
       * [0, block_size), representing how much should the src_extent shift toward
       * larger block number. If this field is non-zero, then src_extent will
       * include 1 extra block in the end, as the merge op actually references the
       * first |src_offset| bytes of that extra block. For example, if |dst_extent|
       * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
       * Note that |src_extent| contains 1 extra block than the |dst_extent|.
       * </pre>
       *
       * <code>optional uint32 src_offset = 4;</code>
       * @return The srcOffset.
       */
      @java.lang.Override
      public int getSrcOffset() {
        return srcOffset_;
      }
      /**
       * <pre>
       * For COW_XOR, source location might be unaligned, so this field is in range
       * [0, block_size), representing how much should the src_extent shift toward
       * larger block number. If this field is non-zero, then src_extent will
       * include 1 extra block in the end, as the merge op actually references the
       * first |src_offset| bytes of that extra block. For example, if |dst_extent|
       * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
       * Note that |src_extent| contains 1 extra block than the |dst_extent|.
       * </pre>
       *
       * <code>optional uint32 src_offset = 4;</code>
       * @param value The srcOffset to set.
       * @return This builder for chaining.
       */
      public Builder setSrcOffset(int value) {
        
        srcOffset_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * For COW_XOR, source location might be unaligned, so this field is in range
       * [0, block_size), representing how much should the src_extent shift toward
       * larger block number. If this field is non-zero, then src_extent will
       * include 1 extra block in the end, as the merge op actually references the
       * first |src_offset| bytes of that extra block. For example, if |dst_extent|
       * is [10, 15], |src_offset| is 500, then src_extent might look like [25, 31].
       * Note that |src_extent| contains 1 extra block than the |dst_extent|.
       * </pre>
       *
       * <code>optional uint32 src_offset = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSrcOffset() {
        bitField0_ = (bitField0_ & ~0x00000008);
        srcOffset_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.CowMergeOperation)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.CowMergeOperation)
    private static final chromeos_update_engine.UpdateMetadata.CowMergeOperation DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.CowMergeOperation();
    }

    public static chromeos_update_engine.UpdateMetadata.CowMergeOperation getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<CowMergeOperation>
        PARSER = new com.google.protobuf.AbstractParser<CowMergeOperation>() {
      @java.lang.Override
      public CowMergeOperation parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<CowMergeOperation> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<CowMergeOperation> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.CowMergeOperation getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PartitionUpdateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.PartitionUpdate)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return Whether the partitionName field is set.
     */
    boolean hasPartitionName();
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return The partitionName.
     */
    java.lang.String getPartitionName();
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return The bytes for partitionName.
     */
    com.google.protobuf.ByteString
        getPartitionNameBytes();

    /**
     * <pre>
     * Whether this partition carries a filesystem with post-install program that
     * must be run to finalize the update process. See also |postinstall_path| and
     * |filesystem_type|.
     * </pre>
     *
     * <code>optional bool run_postinstall = 2;</code>
     * @return Whether the runPostinstall field is set.
     */
    boolean hasRunPostinstall();
    /**
     * <pre>
     * Whether this partition carries a filesystem with post-install program that
     * must be run to finalize the update process. See also |postinstall_path| and
     * |filesystem_type|.
     * </pre>
     *
     * <code>optional bool run_postinstall = 2;</code>
     * @return The runPostinstall.
     */
    boolean getRunPostinstall();

    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return Whether the postinstallPath field is set.
     */
    boolean hasPostinstallPath();
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return The postinstallPath.
     */
    java.lang.String getPostinstallPath();
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return The bytes for postinstallPath.
     */
    com.google.protobuf.ByteString
        getPostinstallPathBytes();

    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return Whether the filesystemType field is set.
     */
    boolean hasFilesystemType();
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return The filesystemType.
     */
    java.lang.String getFilesystemType();
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return The bytes for filesystemType.
     */
    com.google.protobuf.ByteString
        getFilesystemTypeBytes();

    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> 
        getNewPartitionSignatureList();
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    chromeos_update_engine.UpdateMetadata.Signatures.Signature getNewPartitionSignature(int index);
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    int getNewPartitionSignatureCount();
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder> 
        getNewPartitionSignatureOrBuilderList();
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder getNewPartitionSignatureOrBuilder(
        int index);

    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
     * @return Whether the oldPartitionInfo field is set.
     */
    boolean hasOldPartitionInfo();
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
     * @return The oldPartitionInfo.
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfo getOldPartitionInfo();
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getOldPartitionInfoOrBuilder();

    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
     * @return Whether the newPartitionInfo field is set.
     */
    boolean hasNewPartitionInfo();
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
     * @return The newPartitionInfo.
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfo getNewPartitionInfo();
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
     */
    chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getNewPartitionInfoOrBuilder();

    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> 
        getOperationsList();
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    chromeos_update_engine.UpdateMetadata.InstallOperation getOperations(int index);
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    int getOperationsCount();
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder> 
        getOperationsOrBuilderList();
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder getOperationsOrBuilder(
        int index);

    /**
     * <pre>
     * Whether a failure in the postinstall step for this partition should be
     * ignored.
     * </pre>
     *
     * <code>optional bool postinstall_optional = 9;</code>
     * @return Whether the postinstallOptional field is set.
     */
    boolean hasPostinstallOptional();
    /**
     * <pre>
     * Whether a failure in the postinstall step for this partition should be
     * ignored.
     * </pre>
     *
     * <code>optional bool postinstall_optional = 9;</code>
     * @return The postinstallOptional.
     */
    boolean getPostinstallOptional();

    /**
     * <pre>
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
     * @return Whether the hashTreeDataExtent field is set.
     */
    boolean hasHashTreeDataExtent();
    /**
     * <pre>
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
     * @return The hashTreeDataExtent.
     */
    chromeos_update_engine.UpdateMetadata.Extent getHashTreeDataExtent();
    /**
     * <pre>
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
     */
    chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getHashTreeDataExtentOrBuilder();

    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
     * @return Whether the hashTreeExtent field is set.
     */
    boolean hasHashTreeExtent();
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
     * @return The hashTreeExtent.
     */
    chromeos_update_engine.UpdateMetadata.Extent getHashTreeExtent();
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
     */
    chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getHashTreeExtentOrBuilder();

    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return Whether the hashTreeAlgorithm field is set.
     */
    boolean hasHashTreeAlgorithm();
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return The hashTreeAlgorithm.
     */
    java.lang.String getHashTreeAlgorithm();
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return The bytes for hashTreeAlgorithm.
     */
    com.google.protobuf.ByteString
        getHashTreeAlgorithmBytes();

    /**
     * <pre>
     * The salt used for verity hash tree.
     * </pre>
     *
     * <code>optional bytes hash_tree_salt = 13;</code>
     * @return Whether the hashTreeSalt field is set.
     */
    boolean hasHashTreeSalt();
    /**
     * <pre>
     * The salt used for verity hash tree.
     * </pre>
     *
     * <code>optional bytes hash_tree_salt = 13;</code>
     * @return The hashTreeSalt.
     */
    com.google.protobuf.ByteString getHashTreeSalt();

    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
     * @return Whether the fecDataExtent field is set.
     */
    boolean hasFecDataExtent();
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
     * @return The fecDataExtent.
     */
    chromeos_update_engine.UpdateMetadata.Extent getFecDataExtent();
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
     */
    chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getFecDataExtentOrBuilder();

    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
     * @return Whether the fecExtent field is set.
     */
    boolean hasFecExtent();
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
     * @return The fecExtent.
     */
    chromeos_update_engine.UpdateMetadata.Extent getFecExtent();
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
     */
    chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getFecExtentOrBuilder();

    /**
     * <pre>
     * The number of FEC roots.
     * </pre>
     *
     * <code>optional uint32 fec_roots = 16 [default = 2];</code>
     * @return Whether the fecRoots field is set.
     */
    boolean hasFecRoots();
    /**
     * <pre>
     * The number of FEC roots.
     * </pre>
     *
     * <code>optional uint32 fec_roots = 16 [default = 2];</code>
     * @return The fecRoots.
     */
    int getFecRoots();

    /**
     * <pre>
     * Per-partition version used for downgrade detection, added
     * as an effort to support partial updates. For most partitions,
     * this is the build timestamp.
     * </pre>
     *
     * <code>optional string version = 17;</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <pre>
     * Per-partition version used for downgrade detection, added
     * as an effort to support partial updates. For most partitions,
     * this is the build timestamp.
     * </pre>
     *
     * <code>optional string version = 17;</code>
     * @return The version.
     */
    java.lang.String getVersion();
    /**
     * <pre>
     * Per-partition version used for downgrade detection, added
     * as an effort to support partial updates. For most partitions,
     * this is the build timestamp.
     * </pre>
     *
     * <code>optional string version = 17;</code>
     * @return The bytes for version.
     */
    com.google.protobuf.ByteString
        getVersionBytes();

    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.CowMergeOperation> 
        getMergeOperationsList();
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
     */
    chromeos_update_engine.UpdateMetadata.CowMergeOperation getMergeOperations(int index);
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
     */
    int getMergeOperationsCount();
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.CowMergeOperationOrBuilder> 
        getMergeOperationsOrBuilderList();
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
     */
    chromeos_update_engine.UpdateMetadata.CowMergeOperationOrBuilder getMergeOperationsOrBuilder(
        int index);

    /**
     * <pre>
     * Estimated size for COW image. This is used by libsnapshot
     * as a hint. If set to 0, libsnapshot should use alternative
     * methods for estimating size.
     * </pre>
     *
     * <code>optional uint64 estimate_cow_size = 19;</code>
     * @return Whether the estimateCowSize field is set.
     */
    boolean hasEstimateCowSize();
    /**
     * <pre>
     * Estimated size for COW image. This is used by libsnapshot
     * as a hint. If set to 0, libsnapshot should use alternative
     * methods for estimating size.
     * </pre>
     *
     * <code>optional uint64 estimate_cow_size = 19;</code>
     * @return The estimateCowSize.
     */
    long getEstimateCowSize();
  }
  /**
   * <pre>
   * Describes the update to apply to a single partition.
   * </pre>
   *
   * Protobuf type {@code chromeos_update_engine.PartitionUpdate}
   */
  public static final class PartitionUpdate extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.PartitionUpdate)
      PartitionUpdateOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PartitionUpdate.newBuilder() to construct.
    private PartitionUpdate(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PartitionUpdate() {
      partitionName_ = "";
      postinstallPath_ = "";
      filesystemType_ = "";
      newPartitionSignature_ = java.util.Collections.emptyList();
      operations_ = java.util.Collections.emptyList();
      hashTreeAlgorithm_ = "";
      hashTreeSalt_ = com.google.protobuf.ByteString.EMPTY;
      fecRoots_ = 2;
      version_ = "";
      mergeOperations_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PartitionUpdate();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.PartitionUpdate.class, chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder.class);
    }

    private int bitField0_;
    public static final int PARTITION_NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object partitionName_ = "";
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return Whether the partitionName field is set.
     */
    @java.lang.Override
    public boolean hasPartitionName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return The partitionName.
     */
    @java.lang.Override
    public java.lang.String getPartitionName() {
      java.lang.Object ref = partitionName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          partitionName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * A platform-specific name to identify the partition set being updated. For
     * example, in Chrome OS this could be "ROOT" or "KERNEL".
     * </pre>
     *
     * <code>required string partition_name = 1;</code>
     * @return The bytes for partitionName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPartitionNameBytes() {
      java.lang.Object ref = partitionName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        partitionName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RUN_POSTINSTALL_FIELD_NUMBER = 2;
    private boolean runPostinstall_ = false;
    /**
     * <pre>
     * Whether this partition carries a filesystem with post-install program that
     * must be run to finalize the update process. See also |postinstall_path| and
     * |filesystem_type|.
     * </pre>
     *
     * <code>optional bool run_postinstall = 2;</code>
     * @return Whether the runPostinstall field is set.
     */
    @java.lang.Override
    public boolean hasRunPostinstall() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Whether this partition carries a filesystem with post-install program that
     * must be run to finalize the update process. See also |postinstall_path| and
     * |filesystem_type|.
     * </pre>
     *
     * <code>optional bool run_postinstall = 2;</code>
     * @return The runPostinstall.
     */
    @java.lang.Override
    public boolean getRunPostinstall() {
      return runPostinstall_;
    }

    public static final int POSTINSTALL_PATH_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private volatile java.lang.Object postinstallPath_ = "";
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return Whether the postinstallPath field is set.
     */
    @java.lang.Override
    public boolean hasPostinstallPath() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return The postinstallPath.
     */
    @java.lang.Override
    public java.lang.String getPostinstallPath() {
      java.lang.Object ref = postinstallPath_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          postinstallPath_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The path of the executable program to run during the post-install step,
     * relative to the root of this filesystem. If not set, the default "postinst"
     * will be used. This setting is only used when |run_postinstall| is set and
     * true.
     * </pre>
     *
     * <code>optional string postinstall_path = 3;</code>
     * @return The bytes for postinstallPath.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPostinstallPathBytes() {
      java.lang.Object ref = postinstallPath_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        postinstallPath_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FILESYSTEM_TYPE_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object filesystemType_ = "";
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return Whether the filesystemType field is set.
     */
    @java.lang.Override
    public boolean hasFilesystemType() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return The filesystemType.
     */
    @java.lang.Override
    public java.lang.String getFilesystemType() {
      java.lang.Object ref = filesystemType_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          filesystemType_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The filesystem type as passed to the mount(2) syscall when mounting the new
     * filesystem to run the post-install program. If not set, a fixed list of
     * filesystems will be attempted. This setting is only used if
     * |run_postinstall| is set and true.
     * </pre>
     *
     * <code>optional string filesystem_type = 4;</code>
     * @return The bytes for filesystemType.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getFilesystemTypeBytes() {
      java.lang.Object ref = filesystemType_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        filesystemType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NEW_PARTITION_SIGNATURE_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> newPartitionSignature_;
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> getNewPartitionSignatureList() {
      return newPartitionSignature_;
    }
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder> 
        getNewPartitionSignatureOrBuilderList() {
      return newPartitionSignature_;
    }
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    @java.lang.Override
    public int getNewPartitionSignatureCount() {
      return newPartitionSignature_.size();
    }
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Signatures.Signature getNewPartitionSignature(int index) {
      return newPartitionSignature_.get(index);
    }
    /**
     * <pre>
     * If present, a list of signatures of the new_partition_info.hash signed with
     * different keys. If the update_engine daemon requires vendor-signed images
     * and has its public key installed, one of the signatures should be valid
     * for /postinstall to run.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder getNewPartitionSignatureOrBuilder(
        int index) {
      return newPartitionSignature_.get(index);
    }

    public static final int OLD_PARTITION_INFO_FIELD_NUMBER = 6;
    private chromeos_update_engine.UpdateMetadata.PartitionInfo oldPartitionInfo_;
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
     * @return Whether the oldPartitionInfo field is set.
     */
    @java.lang.Override
    public boolean hasOldPartitionInfo() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
     * @return The oldPartitionInfo.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfo getOldPartitionInfo() {
      return oldPartitionInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldPartitionInfo_;
    }
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getOldPartitionInfoOrBuilder() {
      return oldPartitionInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldPartitionInfo_;
    }

    public static final int NEW_PARTITION_INFO_FIELD_NUMBER = 7;
    private chromeos_update_engine.UpdateMetadata.PartitionInfo newPartitionInfo_;
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
     * @return Whether the newPartitionInfo field is set.
     */
    @java.lang.Override
    public boolean hasNewPartitionInfo() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
     * @return The newPartitionInfo.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfo getNewPartitionInfo() {
      return newPartitionInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newPartitionInfo_;
    }
    /**
     * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getNewPartitionInfoOrBuilder() {
      return newPartitionInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newPartitionInfo_;
    }

    public static final int OPERATIONS_FIELD_NUMBER = 8;
    @SuppressWarnings("serial")
    private java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> operations_;
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> getOperationsList() {
      return operations_;
    }
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder> 
        getOperationsOrBuilderList() {
      return operations_;
    }
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    @java.lang.Override
    public int getOperationsCount() {
      return operations_.size();
    }
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.InstallOperation getOperations(int index) {
      return operations_.get(index);
    }
    /**
     * <pre>
     * The list of operations to be performed to apply this PartitionUpdate. The
     * associated operation blobs (in operations[i].data_offset, data_length)
     * should be stored contiguously and in the same order.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder getOperationsOrBuilder(
        int index) {
      return operations_.get(index);
    }

    public static final int POSTINSTALL_OPTIONAL_FIELD_NUMBER = 9;
    private boolean postinstallOptional_ = false;
    /**
     * <pre>
     * Whether a failure in the postinstall step for this partition should be
     * ignored.
     * </pre>
     *
     * <code>optional bool postinstall_optional = 9;</code>
     * @return Whether the postinstallOptional field is set.
     */
    @java.lang.Override
    public boolean hasPostinstallOptional() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Whether a failure in the postinstall step for this partition should be
     * ignored.
     * </pre>
     *
     * <code>optional bool postinstall_optional = 9;</code>
     * @return The postinstallOptional.
     */
    @java.lang.Override
    public boolean getPostinstallOptional() {
      return postinstallOptional_;
    }

    public static final int HASH_TREE_DATA_EXTENT_FIELD_NUMBER = 10;
    private chromeos_update_engine.UpdateMetadata.Extent hashTreeDataExtent_;
    /**
     * <pre>
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
     * @return Whether the hashTreeDataExtent field is set.
     */
    @java.lang.Override
    public boolean hasHashTreeDataExtent() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
     * @return The hashTreeDataExtent.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getHashTreeDataExtent() {
      return hashTreeDataExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeDataExtent_;
    }
    /**
     * <pre>
     * The extent for data covered by verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getHashTreeDataExtentOrBuilder() {
      return hashTreeDataExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeDataExtent_;
    }

    public static final int HASH_TREE_EXTENT_FIELD_NUMBER = 11;
    private chromeos_update_engine.UpdateMetadata.Extent hashTreeExtent_;
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
     * @return Whether the hashTreeExtent field is set.
     */
    @java.lang.Override
    public boolean hasHashTreeExtent() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
     * @return The hashTreeExtent.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getHashTreeExtent() {
      return hashTreeExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeExtent_;
    }
    /**
     * <pre>
     * The extent to store verity hash tree.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getHashTreeExtentOrBuilder() {
      return hashTreeExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeExtent_;
    }

    public static final int HASH_TREE_ALGORITHM_FIELD_NUMBER = 12;
    @SuppressWarnings("serial")
    private volatile java.lang.Object hashTreeAlgorithm_ = "";
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return Whether the hashTreeAlgorithm field is set.
     */
    @java.lang.Override
    public boolean hasHashTreeAlgorithm() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return The hashTreeAlgorithm.
     */
    @java.lang.Override
    public java.lang.String getHashTreeAlgorithm() {
      java.lang.Object ref = hashTreeAlgorithm_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          hashTreeAlgorithm_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The hash algorithm used in verity hash tree.
     * </pre>
     *
     * <code>optional string hash_tree_algorithm = 12;</code>
     * @return The bytes for hashTreeAlgorithm.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getHashTreeAlgorithmBytes() {
      java.lang.Object ref = hashTreeAlgorithm_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        hashTreeAlgorithm_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HASH_TREE_SALT_FIELD_NUMBER = 13;
    private com.google.protobuf.ByteString hashTreeSalt_ = com.google.protobuf.ByteString.EMPTY;
    /**
     * <pre>
     * The salt used for verity hash tree.
     * </pre>
     *
     * <code>optional bytes hash_tree_salt = 13;</code>
     * @return Whether the hashTreeSalt field is set.
     */
    @java.lang.Override
    public boolean hasHashTreeSalt() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * The salt used for verity hash tree.
     * </pre>
     *
     * <code>optional bytes hash_tree_salt = 13;</code>
     * @return The hashTreeSalt.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getHashTreeSalt() {
      return hashTreeSalt_;
    }

    public static final int FEC_DATA_EXTENT_FIELD_NUMBER = 14;
    private chromeos_update_engine.UpdateMetadata.Extent fecDataExtent_;
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
     * @return Whether the fecDataExtent field is set.
     */
    @java.lang.Override
    public boolean hasFecDataExtent() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
     * @return The fecDataExtent.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getFecDataExtent() {
      return fecDataExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecDataExtent_;
    }
    /**
     * <pre>
     * The extent for data covered by FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getFecDataExtentOrBuilder() {
      return fecDataExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecDataExtent_;
    }

    public static final int FEC_EXTENT_FIELD_NUMBER = 15;
    private chromeos_update_engine.UpdateMetadata.Extent fecExtent_;
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
     * @return Whether the fecExtent field is set.
     */
    @java.lang.Override
    public boolean hasFecExtent() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
     * @return The fecExtent.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.Extent getFecExtent() {
      return fecExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecExtent_;
    }
    /**
     * <pre>
     * The extent to store FEC.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getFecExtentOrBuilder() {
      return fecExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecExtent_;
    }

    public static final int FEC_ROOTS_FIELD_NUMBER = 16;
    private int fecRoots_ = 2;
    /**
     * <pre>
     * The number of FEC roots.
     * </pre>
     *
     * <code>optional uint32 fec_roots = 16 [default = 2];</code>
     * @return Whether the fecRoots field is set.
     */
    @java.lang.Override
    public boolean hasFecRoots() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * The number of FEC roots.
     * </pre>
     *
     * <code>optional uint32 fec_roots = 16 [default = 2];</code>
     * @return The fecRoots.
     */
    @java.lang.Override
    public int getFecRoots() {
      return fecRoots_;
    }

    public static final int VERSION_FIELD_NUMBER = 17;
    @SuppressWarnings("serial")
    private volatile java.lang.Object version_ = "";
    /**
     * <pre>
     * Per-partition version used for downgrade detection, added
     * as an effort to support partial updates. For most partitions,
     * this is the build timestamp.
     * </pre>
     *
     * <code>optional string version = 17;</code>
     * @return Whether the version field is set.
     */
    @java.lang.Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * Per-partition version used for downgrade detection, added
     * as an effort to support partial updates. For most partitions,
     * this is the build timestamp.
     * </pre>
     *
     * <code>optional string version = 17;</code>
     * @return The version.
     */
    @java.lang.Override
    public java.lang.String getVersion() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          version_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Per-partition version used for downgrade detection, added
     * as an effort to support partial updates. For most partitions,
     * this is the build timestamp.
     * </pre>
     *
     * <code>optional string version = 17;</code>
     * @return The bytes for version.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVersionBytes() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        version_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int MERGE_OPERATIONS_FIELD_NUMBER = 18;
    @SuppressWarnings("serial")
    private java.util.List<chromeos_update_engine.UpdateMetadata.CowMergeOperation> mergeOperations_;
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.CowMergeOperation> getMergeOperationsList() {
      return mergeOperations_;
    }
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.CowMergeOperationOrBuilder> 
        getMergeOperationsOrBuilderList() {
      return mergeOperations_;
    }
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
     */
    @java.lang.Override
    public int getMergeOperationsCount() {
      return mergeOperations_.size();
    }
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.CowMergeOperation getMergeOperations(int index) {
      return mergeOperations_.get(index);
    }
    /**
     * <pre>
     * A sorted list of CowMergeOperation. When writing cow, we can choose to
     * skip writing the raw bytes for these extents. During snapshot merge, the
     * bytes will read from the source partitions instead.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.CowMergeOperationOrBuilder getMergeOperationsOrBuilder(
        int index) {
      return mergeOperations_.get(index);
    }

    public static final int ESTIMATE_COW_SIZE_FIELD_NUMBER = 19;
    private long estimateCowSize_ = 0L;
    /**
     * <pre>
     * Estimated size for COW image. This is used by libsnapshot
     * as a hint. If set to 0, libsnapshot should use alternative
     * methods for estimating size.
     * </pre>
     *
     * <code>optional uint64 estimate_cow_size = 19;</code>
     * @return Whether the estimateCowSize field is set.
     */
    @java.lang.Override
    public boolean hasEstimateCowSize() {
      return ((bitField0_ & 0x00008000) != 0);
    }
    /**
     * <pre>
     * Estimated size for COW image. This is used by libsnapshot
     * as a hint. If set to 0, libsnapshot should use alternative
     * methods for estimating size.
     * </pre>
     *
     * <code>optional uint64 estimate_cow_size = 19;</code>
     * @return The estimateCowSize.
     */
    @java.lang.Override
    public long getEstimateCowSize() {
      return estimateCowSize_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasPartitionName()) {
        memoizedIsInitialized = 0;
        return false;
      }
      for (int i = 0; i < getOperationsCount(); i++) {
        if (!getOperations(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, partitionName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBool(2, runPostinstall_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, postinstallPath_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, filesystemType_);
      }
      for (int i = 0; i < newPartitionSignature_.size(); i++) {
        output.writeMessage(5, newPartitionSignature_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(6, getOldPartitionInfo());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(7, getNewPartitionInfo());
      }
      for (int i = 0; i < operations_.size(); i++) {
        output.writeMessage(8, operations_.get(i));
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBool(9, postinstallOptional_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeMessage(10, getHashTreeDataExtent());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(11, getHashTreeExtent());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 12, hashTreeAlgorithm_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeBytes(13, hashTreeSalt_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeMessage(14, getFecDataExtent());
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeMessage(15, getFecExtent());
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeUInt32(16, fecRoots_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 17, version_);
      }
      for (int i = 0; i < mergeOperations_.size(); i++) {
        output.writeMessage(18, mergeOperations_.get(i));
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        output.writeUInt64(19, estimateCowSize_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, partitionName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, runPostinstall_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, postinstallPath_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, filesystemType_);
      }
      for (int i = 0; i < newPartitionSignature_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, newPartitionSignature_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getOldPartitionInfo());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getNewPartitionInfo());
      }
      for (int i = 0; i < operations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, operations_.get(i));
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(9, postinstallOptional_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(10, getHashTreeDataExtent());
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getHashTreeExtent());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(12, hashTreeAlgorithm_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(13, hashTreeSalt_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(14, getFecDataExtent());
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, getFecExtent());
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(16, fecRoots_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(17, version_);
      }
      for (int i = 0; i < mergeOperations_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(18, mergeOperations_.get(i));
      }
      if (((bitField0_ & 0x00008000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(19, estimateCowSize_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.PartitionUpdate)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.PartitionUpdate other = (chromeos_update_engine.UpdateMetadata.PartitionUpdate) obj;

      if (hasPartitionName() != other.hasPartitionName()) return false;
      if (hasPartitionName()) {
        if (!getPartitionName()
            .equals(other.getPartitionName())) return false;
      }
      if (hasRunPostinstall() != other.hasRunPostinstall()) return false;
      if (hasRunPostinstall()) {
        if (getRunPostinstall()
            != other.getRunPostinstall()) return false;
      }
      if (hasPostinstallPath() != other.hasPostinstallPath()) return false;
      if (hasPostinstallPath()) {
        if (!getPostinstallPath()
            .equals(other.getPostinstallPath())) return false;
      }
      if (hasFilesystemType() != other.hasFilesystemType()) return false;
      if (hasFilesystemType()) {
        if (!getFilesystemType()
            .equals(other.getFilesystemType())) return false;
      }
      if (!getNewPartitionSignatureList()
          .equals(other.getNewPartitionSignatureList())) return false;
      if (hasOldPartitionInfo() != other.hasOldPartitionInfo()) return false;
      if (hasOldPartitionInfo()) {
        if (!getOldPartitionInfo()
            .equals(other.getOldPartitionInfo())) return false;
      }
      if (hasNewPartitionInfo() != other.hasNewPartitionInfo()) return false;
      if (hasNewPartitionInfo()) {
        if (!getNewPartitionInfo()
            .equals(other.getNewPartitionInfo())) return false;
      }
      if (!getOperationsList()
          .equals(other.getOperationsList())) return false;
      if (hasPostinstallOptional() != other.hasPostinstallOptional()) return false;
      if (hasPostinstallOptional()) {
        if (getPostinstallOptional()
            != other.getPostinstallOptional()) return false;
      }
      if (hasHashTreeDataExtent() != other.hasHashTreeDataExtent()) return false;
      if (hasHashTreeDataExtent()) {
        if (!getHashTreeDataExtent()
            .equals(other.getHashTreeDataExtent())) return false;
      }
      if (hasHashTreeExtent() != other.hasHashTreeExtent()) return false;
      if (hasHashTreeExtent()) {
        if (!getHashTreeExtent()
            .equals(other.getHashTreeExtent())) return false;
      }
      if (hasHashTreeAlgorithm() != other.hasHashTreeAlgorithm()) return false;
      if (hasHashTreeAlgorithm()) {
        if (!getHashTreeAlgorithm()
            .equals(other.getHashTreeAlgorithm())) return false;
      }
      if (hasHashTreeSalt() != other.hasHashTreeSalt()) return false;
      if (hasHashTreeSalt()) {
        if (!getHashTreeSalt()
            .equals(other.getHashTreeSalt())) return false;
      }
      if (hasFecDataExtent() != other.hasFecDataExtent()) return false;
      if (hasFecDataExtent()) {
        if (!getFecDataExtent()
            .equals(other.getFecDataExtent())) return false;
      }
      if (hasFecExtent() != other.hasFecExtent()) return false;
      if (hasFecExtent()) {
        if (!getFecExtent()
            .equals(other.getFecExtent())) return false;
      }
      if (hasFecRoots() != other.hasFecRoots()) return false;
      if (hasFecRoots()) {
        if (getFecRoots()
            != other.getFecRoots()) return false;
      }
      if (hasVersion() != other.hasVersion()) return false;
      if (hasVersion()) {
        if (!getVersion()
            .equals(other.getVersion())) return false;
      }
      if (!getMergeOperationsList()
          .equals(other.getMergeOperationsList())) return false;
      if (hasEstimateCowSize() != other.hasEstimateCowSize()) return false;
      if (hasEstimateCowSize()) {
        if (getEstimateCowSize()
            != other.getEstimateCowSize()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPartitionName()) {
        hash = (37 * hash) + PARTITION_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getPartitionName().hashCode();
      }
      if (hasRunPostinstall()) {
        hash = (37 * hash) + RUN_POSTINSTALL_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getRunPostinstall());
      }
      if (hasPostinstallPath()) {
        hash = (37 * hash) + POSTINSTALL_PATH_FIELD_NUMBER;
        hash = (53 * hash) + getPostinstallPath().hashCode();
      }
      if (hasFilesystemType()) {
        hash = (37 * hash) + FILESYSTEM_TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getFilesystemType().hashCode();
      }
      if (getNewPartitionSignatureCount() > 0) {
        hash = (37 * hash) + NEW_PARTITION_SIGNATURE_FIELD_NUMBER;
        hash = (53 * hash) + getNewPartitionSignatureList().hashCode();
      }
      if (hasOldPartitionInfo()) {
        hash = (37 * hash) + OLD_PARTITION_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getOldPartitionInfo().hashCode();
      }
      if (hasNewPartitionInfo()) {
        hash = (37 * hash) + NEW_PARTITION_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getNewPartitionInfo().hashCode();
      }
      if (getOperationsCount() > 0) {
        hash = (37 * hash) + OPERATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getOperationsList().hashCode();
      }
      if (hasPostinstallOptional()) {
        hash = (37 * hash) + POSTINSTALL_OPTIONAL_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPostinstallOptional());
      }
      if (hasHashTreeDataExtent()) {
        hash = (37 * hash) + HASH_TREE_DATA_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getHashTreeDataExtent().hashCode();
      }
      if (hasHashTreeExtent()) {
        hash = (37 * hash) + HASH_TREE_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getHashTreeExtent().hashCode();
      }
      if (hasHashTreeAlgorithm()) {
        hash = (37 * hash) + HASH_TREE_ALGORITHM_FIELD_NUMBER;
        hash = (53 * hash) + getHashTreeAlgorithm().hashCode();
      }
      if (hasHashTreeSalt()) {
        hash = (37 * hash) + HASH_TREE_SALT_FIELD_NUMBER;
        hash = (53 * hash) + getHashTreeSalt().hashCode();
      }
      if (hasFecDataExtent()) {
        hash = (37 * hash) + FEC_DATA_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getFecDataExtent().hashCode();
      }
      if (hasFecExtent()) {
        hash = (37 * hash) + FEC_EXTENT_FIELD_NUMBER;
        hash = (53 * hash) + getFecExtent().hashCode();
      }
      if (hasFecRoots()) {
        hash = (37 * hash) + FEC_ROOTS_FIELD_NUMBER;
        hash = (53 * hash) + getFecRoots();
      }
      if (hasVersion()) {
        hash = (37 * hash) + VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getVersion().hashCode();
      }
      if (getMergeOperationsCount() > 0) {
        hash = (37 * hash) + MERGE_OPERATIONS_FIELD_NUMBER;
        hash = (53 * hash) + getMergeOperationsList().hashCode();
      }
      if (hasEstimateCowSize()) {
        hash = (37 * hash) + ESTIMATE_COW_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getEstimateCowSize());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.PartitionUpdate prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Describes the update to apply to a single partition.
     * </pre>
     *
     * Protobuf type {@code chromeos_update_engine.PartitionUpdate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.PartitionUpdate)
        chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.PartitionUpdate.class, chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.PartitionUpdate.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getNewPartitionSignatureFieldBuilder();
          getOldPartitionInfoFieldBuilder();
          getNewPartitionInfoFieldBuilder();
          getOperationsFieldBuilder();
          getHashTreeDataExtentFieldBuilder();
          getHashTreeExtentFieldBuilder();
          getFecDataExtentFieldBuilder();
          getFecExtentFieldBuilder();
          getMergeOperationsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        partitionName_ = "";
        runPostinstall_ = false;
        postinstallPath_ = "";
        filesystemType_ = "";
        if (newPartitionSignatureBuilder_ == null) {
          newPartitionSignature_ = java.util.Collections.emptyList();
        } else {
          newPartitionSignature_ = null;
          newPartitionSignatureBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        oldPartitionInfo_ = null;
        if (oldPartitionInfoBuilder_ != null) {
          oldPartitionInfoBuilder_.dispose();
          oldPartitionInfoBuilder_ = null;
        }
        newPartitionInfo_ = null;
        if (newPartitionInfoBuilder_ != null) {
          newPartitionInfoBuilder_.dispose();
          newPartitionInfoBuilder_ = null;
        }
        if (operationsBuilder_ == null) {
          operations_ = java.util.Collections.emptyList();
        } else {
          operations_ = null;
          operationsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000080);
        postinstallOptional_ = false;
        hashTreeDataExtent_ = null;
        if (hashTreeDataExtentBuilder_ != null) {
          hashTreeDataExtentBuilder_.dispose();
          hashTreeDataExtentBuilder_ = null;
        }
        hashTreeExtent_ = null;
        if (hashTreeExtentBuilder_ != null) {
          hashTreeExtentBuilder_.dispose();
          hashTreeExtentBuilder_ = null;
        }
        hashTreeAlgorithm_ = "";
        hashTreeSalt_ = com.google.protobuf.ByteString.EMPTY;
        fecDataExtent_ = null;
        if (fecDataExtentBuilder_ != null) {
          fecDataExtentBuilder_.dispose();
          fecDataExtentBuilder_ = null;
        }
        fecExtent_ = null;
        if (fecExtentBuilder_ != null) {
          fecExtentBuilder_.dispose();
          fecExtentBuilder_ = null;
        }
        fecRoots_ = 2;
        version_ = "";
        if (mergeOperationsBuilder_ == null) {
          mergeOperations_ = java.util.Collections.emptyList();
        } else {
          mergeOperations_ = null;
          mergeOperationsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00020000);
        estimateCowSize_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_PartitionUpdate_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.PartitionUpdate getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.PartitionUpdate.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.PartitionUpdate build() {
        chromeos_update_engine.UpdateMetadata.PartitionUpdate result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.PartitionUpdate buildPartial() {
        chromeos_update_engine.UpdateMetadata.PartitionUpdate result = new chromeos_update_engine.UpdateMetadata.PartitionUpdate(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(chromeos_update_engine.UpdateMetadata.PartitionUpdate result) {
        if (newPartitionSignatureBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0)) {
            newPartitionSignature_ = java.util.Collections.unmodifiableList(newPartitionSignature_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.newPartitionSignature_ = newPartitionSignature_;
        } else {
          result.newPartitionSignature_ = newPartitionSignatureBuilder_.build();
        }
        if (operationsBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0)) {
            operations_ = java.util.Collections.unmodifiableList(operations_);
            bitField0_ = (bitField0_ & ~0x00000080);
          }
          result.operations_ = operations_;
        } else {
          result.operations_ = operationsBuilder_.build();
        }
        if (mergeOperationsBuilder_ == null) {
          if (((bitField0_ & 0x00020000) != 0)) {
            mergeOperations_ = java.util.Collections.unmodifiableList(mergeOperations_);
            bitField0_ = (bitField0_ & ~0x00020000);
          }
          result.mergeOperations_ = mergeOperations_;
        } else {
          result.mergeOperations_ = mergeOperationsBuilder_.build();
        }
      }

      private void buildPartial0(chromeos_update_engine.UpdateMetadata.PartitionUpdate result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.partitionName_ = partitionName_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.runPostinstall_ = runPostinstall_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.postinstallPath_ = postinstallPath_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.filesystemType_ = filesystemType_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.oldPartitionInfo_ = oldPartitionInfoBuilder_ == null
              ? oldPartitionInfo_
              : oldPartitionInfoBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.newPartitionInfo_ = newPartitionInfoBuilder_ == null
              ? newPartitionInfo_
              : newPartitionInfoBuilder_.build();
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.postinstallOptional_ = postinstallOptional_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.hashTreeDataExtent_ = hashTreeDataExtentBuilder_ == null
              ? hashTreeDataExtent_
              : hashTreeDataExtentBuilder_.build();
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.hashTreeExtent_ = hashTreeExtentBuilder_ == null
              ? hashTreeExtent_
              : hashTreeExtentBuilder_.build();
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.hashTreeAlgorithm_ = hashTreeAlgorithm_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.hashTreeSalt_ = hashTreeSalt_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.fecDataExtent_ = fecDataExtentBuilder_ == null
              ? fecDataExtent_
              : fecDataExtentBuilder_.build();
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          result.fecExtent_ = fecExtentBuilder_ == null
              ? fecExtent_
              : fecExtentBuilder_.build();
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          result.fecRoots_ = fecRoots_;
          to_bitField0_ |= 0x00002000;
        }
        if (((from_bitField0_ & 0x00010000) != 0)) {
          result.version_ = version_;
          to_bitField0_ |= 0x00004000;
        }
        if (((from_bitField0_ & 0x00040000) != 0)) {
          result.estimateCowSize_ = estimateCowSize_;
          to_bitField0_ |= 0x00008000;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.PartitionUpdate) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.PartitionUpdate)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.PartitionUpdate other) {
        if (other == chromeos_update_engine.UpdateMetadata.PartitionUpdate.getDefaultInstance()) return this;
        if (other.hasPartitionName()) {
          partitionName_ = other.partitionName_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasRunPostinstall()) {
          setRunPostinstall(other.getRunPostinstall());
        }
        if (other.hasPostinstallPath()) {
          postinstallPath_ = other.postinstallPath_;
          bitField0_ |= 0x00000004;
          onChanged();
        }
        if (other.hasFilesystemType()) {
          filesystemType_ = other.filesystemType_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (newPartitionSignatureBuilder_ == null) {
          if (!other.newPartitionSignature_.isEmpty()) {
            if (newPartitionSignature_.isEmpty()) {
              newPartitionSignature_ = other.newPartitionSignature_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureNewPartitionSignatureIsMutable();
              newPartitionSignature_.addAll(other.newPartitionSignature_);
            }
            onChanged();
          }
        } else {
          if (!other.newPartitionSignature_.isEmpty()) {
            if (newPartitionSignatureBuilder_.isEmpty()) {
              newPartitionSignatureBuilder_.dispose();
              newPartitionSignatureBuilder_ = null;
              newPartitionSignature_ = other.newPartitionSignature_;
              bitField0_ = (bitField0_ & ~0x00000010);
              newPartitionSignatureBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getNewPartitionSignatureFieldBuilder() : null;
            } else {
              newPartitionSignatureBuilder_.addAllMessages(other.newPartitionSignature_);
            }
          }
        }
        if (other.hasOldPartitionInfo()) {
          mergeOldPartitionInfo(other.getOldPartitionInfo());
        }
        if (other.hasNewPartitionInfo()) {
          mergeNewPartitionInfo(other.getNewPartitionInfo());
        }
        if (operationsBuilder_ == null) {
          if (!other.operations_.isEmpty()) {
            if (operations_.isEmpty()) {
              operations_ = other.operations_;
              bitField0_ = (bitField0_ & ~0x00000080);
            } else {
              ensureOperationsIsMutable();
              operations_.addAll(other.operations_);
            }
            onChanged();
          }
        } else {
          if (!other.operations_.isEmpty()) {
            if (operationsBuilder_.isEmpty()) {
              operationsBuilder_.dispose();
              operationsBuilder_ = null;
              operations_ = other.operations_;
              bitField0_ = (bitField0_ & ~0x00000080);
              operationsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getOperationsFieldBuilder() : null;
            } else {
              operationsBuilder_.addAllMessages(other.operations_);
            }
          }
        }
        if (other.hasPostinstallOptional()) {
          setPostinstallOptional(other.getPostinstallOptional());
        }
        if (other.hasHashTreeDataExtent()) {
          mergeHashTreeDataExtent(other.getHashTreeDataExtent());
        }
        if (other.hasHashTreeExtent()) {
          mergeHashTreeExtent(other.getHashTreeExtent());
        }
        if (other.hasHashTreeAlgorithm()) {
          hashTreeAlgorithm_ = other.hashTreeAlgorithm_;
          bitField0_ |= 0x00000800;
          onChanged();
        }
        if (other.hasHashTreeSalt()) {
          setHashTreeSalt(other.getHashTreeSalt());
        }
        if (other.hasFecDataExtent()) {
          mergeFecDataExtent(other.getFecDataExtent());
        }
        if (other.hasFecExtent()) {
          mergeFecExtent(other.getFecExtent());
        }
        if (other.hasFecRoots()) {
          setFecRoots(other.getFecRoots());
        }
        if (other.hasVersion()) {
          version_ = other.version_;
          bitField0_ |= 0x00010000;
          onChanged();
        }
        if (mergeOperationsBuilder_ == null) {
          if (!other.mergeOperations_.isEmpty()) {
            if (mergeOperations_.isEmpty()) {
              mergeOperations_ = other.mergeOperations_;
              bitField0_ = (bitField0_ & ~0x00020000);
            } else {
              ensureMergeOperationsIsMutable();
              mergeOperations_.addAll(other.mergeOperations_);
            }
            onChanged();
          }
        } else {
          if (!other.mergeOperations_.isEmpty()) {
            if (mergeOperationsBuilder_.isEmpty()) {
              mergeOperationsBuilder_.dispose();
              mergeOperationsBuilder_ = null;
              mergeOperations_ = other.mergeOperations_;
              bitField0_ = (bitField0_ & ~0x00020000);
              mergeOperationsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getMergeOperationsFieldBuilder() : null;
            } else {
              mergeOperationsBuilder_.addAllMessages(other.mergeOperations_);
            }
          }
        }
        if (other.hasEstimateCowSize()) {
          setEstimateCowSize(other.getEstimateCowSize());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasPartitionName()) {
          return false;
        }
        for (int i = 0; i < getOperationsCount(); i++) {
          if (!getOperations(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                partitionName_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                runPostinstall_ = input.readBool();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                postinstallPath_ = input.readBytes();
                bitField0_ |= 0x00000004;
                break;
              } // case 26
              case 34: {
                filesystemType_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 42: {
                chromeos_update_engine.UpdateMetadata.Signatures.Signature m =
                    input.readMessage(
                        chromeos_update_engine.UpdateMetadata.Signatures.Signature.PARSER,
                        extensionRegistry);
                if (newPartitionSignatureBuilder_ == null) {
                  ensureNewPartitionSignatureIsMutable();
                  newPartitionSignature_.add(m);
                } else {
                  newPartitionSignatureBuilder_.addMessage(m);
                }
                break;
              } // case 42
              case 50: {
                input.readMessage(
                    getOldPartitionInfoFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              case 58: {
                input.readMessage(
                    getNewPartitionInfoFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 58
              case 66: {
                chromeos_update_engine.UpdateMetadata.InstallOperation m =
                    input.readMessage(
                        chromeos_update_engine.UpdateMetadata.InstallOperation.PARSER,
                        extensionRegistry);
                if (operationsBuilder_ == null) {
                  ensureOperationsIsMutable();
                  operations_.add(m);
                } else {
                  operationsBuilder_.addMessage(m);
                }
                break;
              } // case 66
              case 72: {
                postinstallOptional_ = input.readBool();
                bitField0_ |= 0x00000100;
                break;
              } // case 72
              case 82: {
                input.readMessage(
                    getHashTreeDataExtentFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000200;
                break;
              } // case 82
              case 90: {
                input.readMessage(
                    getHashTreeExtentFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000400;
                break;
              } // case 90
              case 98: {
                hashTreeAlgorithm_ = input.readBytes();
                bitField0_ |= 0x00000800;
                break;
              } // case 98
              case 106: {
                hashTreeSalt_ = input.readBytes();
                bitField0_ |= 0x00001000;
                break;
              } // case 106
              case 114: {
                input.readMessage(
                    getFecDataExtentFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00002000;
                break;
              } // case 114
              case 122: {
                input.readMessage(
                    getFecExtentFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00004000;
                break;
              } // case 122
              case 128: {
                fecRoots_ = input.readUInt32();
                bitField0_ |= 0x00008000;
                break;
              } // case 128
              case 138: {
                version_ = input.readBytes();
                bitField0_ |= 0x00010000;
                break;
              } // case 138
              case 146: {
                chromeos_update_engine.UpdateMetadata.CowMergeOperation m =
                    input.readMessage(
                        chromeos_update_engine.UpdateMetadata.CowMergeOperation.PARSER,
                        extensionRegistry);
                if (mergeOperationsBuilder_ == null) {
                  ensureMergeOperationsIsMutable();
                  mergeOperations_.add(m);
                } else {
                  mergeOperationsBuilder_.addMessage(m);
                }
                break;
              } // case 146
              case 152: {
                estimateCowSize_ = input.readUInt64();
                bitField0_ |= 0x00040000;
                break;
              } // case 152
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object partitionName_ = "";
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @return Whether the partitionName field is set.
       */
      public boolean hasPartitionName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @return The partitionName.
       */
      public java.lang.String getPartitionName() {
        java.lang.Object ref = partitionName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            partitionName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @return The bytes for partitionName.
       */
      public com.google.protobuf.ByteString
          getPartitionNameBytes() {
        java.lang.Object ref = partitionName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          partitionName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @param value The partitionName to set.
       * @return This builder for chaining.
       */
      public Builder setPartitionName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        partitionName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPartitionName() {
        partitionName_ = getDefaultInstance().getPartitionName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A platform-specific name to identify the partition set being updated. For
       * example, in Chrome OS this could be "ROOT" or "KERNEL".
       * </pre>
       *
       * <code>required string partition_name = 1;</code>
       * @param value The bytes for partitionName to set.
       * @return This builder for chaining.
       */
      public Builder setPartitionNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        partitionName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private boolean runPostinstall_ ;
      /**
       * <pre>
       * Whether this partition carries a filesystem with post-install program that
       * must be run to finalize the update process. See also |postinstall_path| and
       * |filesystem_type|.
       * </pre>
       *
       * <code>optional bool run_postinstall = 2;</code>
       * @return Whether the runPostinstall field is set.
       */
      @java.lang.Override
      public boolean hasRunPostinstall() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Whether this partition carries a filesystem with post-install program that
       * must be run to finalize the update process. See also |postinstall_path| and
       * |filesystem_type|.
       * </pre>
       *
       * <code>optional bool run_postinstall = 2;</code>
       * @return The runPostinstall.
       */
      @java.lang.Override
      public boolean getRunPostinstall() {
        return runPostinstall_;
      }
      /**
       * <pre>
       * Whether this partition carries a filesystem with post-install program that
       * must be run to finalize the update process. See also |postinstall_path| and
       * |filesystem_type|.
       * </pre>
       *
       * <code>optional bool run_postinstall = 2;</code>
       * @param value The runPostinstall to set.
       * @return This builder for chaining.
       */
      public Builder setRunPostinstall(boolean value) {
        
        runPostinstall_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether this partition carries a filesystem with post-install program that
       * must be run to finalize the update process. See also |postinstall_path| and
       * |filesystem_type|.
       * </pre>
       *
       * <code>optional bool run_postinstall = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearRunPostinstall() {
        bitField0_ = (bitField0_ & ~0x00000002);
        runPostinstall_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object postinstallPath_ = "";
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @return Whether the postinstallPath field is set.
       */
      public boolean hasPostinstallPath() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @return The postinstallPath.
       */
      public java.lang.String getPostinstallPath() {
        java.lang.Object ref = postinstallPath_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            postinstallPath_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @return The bytes for postinstallPath.
       */
      public com.google.protobuf.ByteString
          getPostinstallPathBytes() {
        java.lang.Object ref = postinstallPath_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          postinstallPath_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @param value The postinstallPath to set.
       * @return This builder for chaining.
       */
      public Builder setPostinstallPath(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        postinstallPath_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPostinstallPath() {
        postinstallPath_ = getDefaultInstance().getPostinstallPath();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The path of the executable program to run during the post-install step,
       * relative to the root of this filesystem. If not set, the default "postinst"
       * will be used. This setting is only used when |run_postinstall| is set and
       * true.
       * </pre>
       *
       * <code>optional string postinstall_path = 3;</code>
       * @param value The bytes for postinstallPath to set.
       * @return This builder for chaining.
       */
      public Builder setPostinstallPathBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        postinstallPath_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private java.lang.Object filesystemType_ = "";
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @return Whether the filesystemType field is set.
       */
      public boolean hasFilesystemType() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @return The filesystemType.
       */
      public java.lang.String getFilesystemType() {
        java.lang.Object ref = filesystemType_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            filesystemType_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @return The bytes for filesystemType.
       */
      public com.google.protobuf.ByteString
          getFilesystemTypeBytes() {
        java.lang.Object ref = filesystemType_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          filesystemType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @param value The filesystemType to set.
       * @return This builder for chaining.
       */
      public Builder setFilesystemType(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        filesystemType_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFilesystemType() {
        filesystemType_ = getDefaultInstance().getFilesystemType();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The filesystem type as passed to the mount(2) syscall when mounting the new
       * filesystem to run the post-install program. If not set, a fixed list of
       * filesystems will be attempted. This setting is only used if
       * |run_postinstall| is set and true.
       * </pre>
       *
       * <code>optional string filesystem_type = 4;</code>
       * @param value The bytes for filesystemType to set.
       * @return This builder for chaining.
       */
      public Builder setFilesystemTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        filesystemType_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> newPartitionSignature_ =
        java.util.Collections.emptyList();
      private void ensureNewPartitionSignatureIsMutable() {
        if (!((bitField0_ & 0x00000010) != 0)) {
          newPartitionSignature_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.Signatures.Signature>(newPartitionSignature_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Signatures.Signature, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder, chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder> newPartitionSignatureBuilder_;

      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature> getNewPartitionSignatureList() {
        if (newPartitionSignatureBuilder_ == null) {
          return java.util.Collections.unmodifiableList(newPartitionSignature_);
        } else {
          return newPartitionSignatureBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public int getNewPartitionSignatureCount() {
        if (newPartitionSignatureBuilder_ == null) {
          return newPartitionSignature_.size();
        } else {
          return newPartitionSignatureBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature getNewPartitionSignature(int index) {
        if (newPartitionSignatureBuilder_ == null) {
          return newPartitionSignature_.get(index);
        } else {
          return newPartitionSignatureBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder setNewPartitionSignature(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature value) {
        if (newPartitionSignatureBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.set(index, value);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder setNewPartitionSignature(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder builderForValue) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.set(index, builderForValue.build());
          onChanged();
        } else {
          newPartitionSignatureBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addNewPartitionSignature(chromeos_update_engine.UpdateMetadata.Signatures.Signature value) {
        if (newPartitionSignatureBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.add(value);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addNewPartitionSignature(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature value) {
        if (newPartitionSignatureBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.add(index, value);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addNewPartitionSignature(
          chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder builderForValue) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.add(builderForValue.build());
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addNewPartitionSignature(
          int index, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder builderForValue) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.add(index, builderForValue.build());
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder addAllNewPartitionSignature(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.Signatures.Signature> values) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, newPartitionSignature_);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder clearNewPartitionSignature() {
        if (newPartitionSignatureBuilder_ == null) {
          newPartitionSignature_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public Builder removeNewPartitionSignature(int index) {
        if (newPartitionSignatureBuilder_ == null) {
          ensureNewPartitionSignatureIsMutable();
          newPartitionSignature_.remove(index);
          onChanged();
        } else {
          newPartitionSignatureBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder getNewPartitionSignatureBuilder(
          int index) {
        return getNewPartitionSignatureFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder getNewPartitionSignatureOrBuilder(
          int index) {
        if (newPartitionSignatureBuilder_ == null) {
          return newPartitionSignature_.get(index);  } else {
          return newPartitionSignatureBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder> 
           getNewPartitionSignatureOrBuilderList() {
        if (newPartitionSignatureBuilder_ != null) {
          return newPartitionSignatureBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(newPartitionSignature_);
        }
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder addNewPartitionSignatureBuilder() {
        return getNewPartitionSignatureFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.Signatures.Signature.getDefaultInstance());
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder addNewPartitionSignatureBuilder(
          int index) {
        return getNewPartitionSignatureFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.Signatures.Signature.getDefaultInstance());
      }
      /**
       * <pre>
       * If present, a list of signatures of the new_partition_info.hash signed with
       * different keys. If the update_engine daemon requires vendor-signed images
       * and has its public key installed, one of the signatures should be valid
       * for /postinstall to run.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder> 
           getNewPartitionSignatureBuilderList() {
        return getNewPartitionSignatureFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Signatures.Signature, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder, chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder> 
          getNewPartitionSignatureFieldBuilder() {
        if (newPartitionSignatureBuilder_ == null) {
          newPartitionSignatureBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Signatures.Signature, chromeos_update_engine.UpdateMetadata.Signatures.Signature.Builder, chromeos_update_engine.UpdateMetadata.Signatures.SignatureOrBuilder>(
                  newPartitionSignature_,
                  ((bitField0_ & 0x00000010) != 0),
                  getParentForChildren(),
                  isClean());
          newPartitionSignature_ = null;
        }
        return newPartitionSignatureBuilder_;
      }

      private chromeos_update_engine.UpdateMetadata.PartitionInfo oldPartitionInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder> oldPartitionInfoBuilder_;
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       * @return Whether the oldPartitionInfo field is set.
       */
      public boolean hasOldPartitionInfo() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       * @return The oldPartitionInfo.
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo getOldPartitionInfo() {
        if (oldPartitionInfoBuilder_ == null) {
          return oldPartitionInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldPartitionInfo_;
        } else {
          return oldPartitionInfoBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       */
      public Builder setOldPartitionInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (oldPartitionInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          oldPartitionInfo_ = value;
        } else {
          oldPartitionInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       */
      public Builder setOldPartitionInfo(
          chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder builderForValue) {
        if (oldPartitionInfoBuilder_ == null) {
          oldPartitionInfo_ = builderForValue.build();
        } else {
          oldPartitionInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       */
      public Builder mergeOldPartitionInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (oldPartitionInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
            oldPartitionInfo_ != null &&
            oldPartitionInfo_ != chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance()) {
            getOldPartitionInfoBuilder().mergeFrom(value);
          } else {
            oldPartitionInfo_ = value;
          }
        } else {
          oldPartitionInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       */
      public Builder clearOldPartitionInfo() {
        bitField0_ = (bitField0_ & ~0x00000020);
        oldPartitionInfo_ = null;
        if (oldPartitionInfoBuilder_ != null) {
          oldPartitionInfoBuilder_.dispose();
          oldPartitionInfoBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder getOldPartitionInfoBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getOldPartitionInfoFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getOldPartitionInfoOrBuilder() {
        if (oldPartitionInfoBuilder_ != null) {
          return oldPartitionInfoBuilder_.getMessageOrBuilder();
        } else {
          return oldPartitionInfo_ == null ?
              chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : oldPartitionInfo_;
        }
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder> 
          getOldPartitionInfoFieldBuilder() {
        if (oldPartitionInfoBuilder_ == null) {
          oldPartitionInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder>(
                  getOldPartitionInfo(),
                  getParentForChildren(),
                  isClean());
          oldPartitionInfo_ = null;
        }
        return oldPartitionInfoBuilder_;
      }

      private chromeos_update_engine.UpdateMetadata.PartitionInfo newPartitionInfo_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder> newPartitionInfoBuilder_;
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       * @return Whether the newPartitionInfo field is set.
       */
      public boolean hasNewPartitionInfo() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       * @return The newPartitionInfo.
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo getNewPartitionInfo() {
        if (newPartitionInfoBuilder_ == null) {
          return newPartitionInfo_ == null ? chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newPartitionInfo_;
        } else {
          return newPartitionInfoBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       */
      public Builder setNewPartitionInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (newPartitionInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          newPartitionInfo_ = value;
        } else {
          newPartitionInfoBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       */
      public Builder setNewPartitionInfo(
          chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder builderForValue) {
        if (newPartitionInfoBuilder_ == null) {
          newPartitionInfo_ = builderForValue.build();
        } else {
          newPartitionInfoBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       */
      public Builder mergeNewPartitionInfo(chromeos_update_engine.UpdateMetadata.PartitionInfo value) {
        if (newPartitionInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            newPartitionInfo_ != null &&
            newPartitionInfo_ != chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance()) {
            getNewPartitionInfoBuilder().mergeFrom(value);
          } else {
            newPartitionInfo_ = value;
          }
        } else {
          newPartitionInfoBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       */
      public Builder clearNewPartitionInfo() {
        bitField0_ = (bitField0_ & ~0x00000040);
        newPartitionInfo_ = null;
        if (newPartitionInfoBuilder_ != null) {
          newPartitionInfoBuilder_.dispose();
          newPartitionInfoBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder getNewPartitionInfoBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getNewPartitionInfoFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder getNewPartitionInfoOrBuilder() {
        if (newPartitionInfoBuilder_ != null) {
          return newPartitionInfoBuilder_.getMessageOrBuilder();
        } else {
          return newPartitionInfo_ == null ?
              chromeos_update_engine.UpdateMetadata.PartitionInfo.getDefaultInstance() : newPartitionInfo_;
        }
      }
      /**
       * <code>optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder> 
          getNewPartitionInfoFieldBuilder() {
        if (newPartitionInfoBuilder_ == null) {
          newPartitionInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.PartitionInfo, chromeos_update_engine.UpdateMetadata.PartitionInfo.Builder, chromeos_update_engine.UpdateMetadata.PartitionInfoOrBuilder>(
                  getNewPartitionInfo(),
                  getParentForChildren(),
                  isClean());
          newPartitionInfo_ = null;
        }
        return newPartitionInfoBuilder_;
      }

      private java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> operations_ =
        java.util.Collections.emptyList();
      private void ensureOperationsIsMutable() {
        if (!((bitField0_ & 0x00000080) != 0)) {
          operations_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.InstallOperation>(operations_);
          bitField0_ |= 0x00000080;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.InstallOperation, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder, chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder> operationsBuilder_;

      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation> getOperationsList() {
        if (operationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(operations_);
        } else {
          return operationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public int getOperationsCount() {
        if (operationsBuilder_ == null) {
          return operations_.size();
        } else {
          return operationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation getOperations(int index) {
        if (operationsBuilder_ == null) {
          return operations_.get(index);
        } else {
          return operationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder setOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation value) {
        if (operationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOperationsIsMutable();
          operations_.set(index, value);
          onChanged();
        } else {
          operationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder setOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder builderForValue) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          operations_.set(index, builderForValue.build());
          onChanged();
        } else {
          operationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder addOperations(chromeos_update_engine.UpdateMetadata.InstallOperation value) {
        if (operationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOperationsIsMutable();
          operations_.add(value);
          onChanged();
        } else {
          operationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder addOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation value) {
        if (operationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureOperationsIsMutable();
          operations_.add(index, value);
          onChanged();
        } else {
          operationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder addOperations(
          chromeos_update_engine.UpdateMetadata.InstallOperation.Builder builderForValue) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          operations_.add(builderForValue.build());
          onChanged();
        } else {
          operationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder addOperations(
          int index, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder builderForValue) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          operations_.add(index, builderForValue.build());
          onChanged();
        } else {
          operationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder addAllOperations(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.InstallOperation> values) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, operations_);
          onChanged();
        } else {
          operationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder clearOperations() {
        if (operationsBuilder_ == null) {
          operations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000080);
          onChanged();
        } else {
          operationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public Builder removeOperations(int index) {
        if (operationsBuilder_ == null) {
          ensureOperationsIsMutable();
          operations_.remove(index);
          onChanged();
        } else {
          operationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation.Builder getOperationsBuilder(
          int index) {
        return getOperationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder getOperationsOrBuilder(
          int index) {
        if (operationsBuilder_ == null) {
          return operations_.get(index);  } else {
          return operationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder> 
           getOperationsOrBuilderList() {
        if (operationsBuilder_ != null) {
          return operationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(operations_);
        }
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation.Builder addOperationsBuilder() {
        return getOperationsFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.InstallOperation.getDefaultInstance());
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public chromeos_update_engine.UpdateMetadata.InstallOperation.Builder addOperationsBuilder(
          int index) {
        return getOperationsFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.InstallOperation.getDefaultInstance());
      }
      /**
       * <pre>
       * The list of operations to be performed to apply this PartitionUpdate. The
       * associated operation blobs (in operations[i].data_offset, data_length)
       * should be stored contiguously and in the same order.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.InstallOperation operations = 8;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.InstallOperation.Builder> 
           getOperationsBuilderList() {
        return getOperationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.InstallOperation, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder, chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder> 
          getOperationsFieldBuilder() {
        if (operationsBuilder_ == null) {
          operationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.InstallOperation, chromeos_update_engine.UpdateMetadata.InstallOperation.Builder, chromeos_update_engine.UpdateMetadata.InstallOperationOrBuilder>(
                  operations_,
                  ((bitField0_ & 0x00000080) != 0),
                  getParentForChildren(),
                  isClean());
          operations_ = null;
        }
        return operationsBuilder_;
      }

      private boolean postinstallOptional_ ;
      /**
       * <pre>
       * Whether a failure in the postinstall step for this partition should be
       * ignored.
       * </pre>
       *
       * <code>optional bool postinstall_optional = 9;</code>
       * @return Whether the postinstallOptional field is set.
       */
      @java.lang.Override
      public boolean hasPostinstallOptional() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Whether a failure in the postinstall step for this partition should be
       * ignored.
       * </pre>
       *
       * <code>optional bool postinstall_optional = 9;</code>
       * @return The postinstallOptional.
       */
      @java.lang.Override
      public boolean getPostinstallOptional() {
        return postinstallOptional_;
      }
      /**
       * <pre>
       * Whether a failure in the postinstall step for this partition should be
       * ignored.
       * </pre>
       *
       * <code>optional bool postinstall_optional = 9;</code>
       * @param value The postinstallOptional to set.
       * @return This builder for chaining.
       */
      public Builder setPostinstallOptional(boolean value) {
        
        postinstallOptional_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether a failure in the postinstall step for this partition should be
       * ignored.
       * </pre>
       *
       * <code>optional bool postinstall_optional = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearPostinstallOptional() {
        bitField0_ = (bitField0_ & ~0x00000100);
        postinstallOptional_ = false;
        onChanged();
        return this;
      }

      private chromeos_update_engine.UpdateMetadata.Extent hashTreeDataExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> hashTreeDataExtentBuilder_;
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       * @return Whether the hashTreeDataExtent field is set.
       */
      public boolean hasHashTreeDataExtent() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       * @return The hashTreeDataExtent.
       */
      public chromeos_update_engine.UpdateMetadata.Extent getHashTreeDataExtent() {
        if (hashTreeDataExtentBuilder_ == null) {
          return hashTreeDataExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeDataExtent_;
        } else {
          return hashTreeDataExtentBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       */
      public Builder setHashTreeDataExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (hashTreeDataExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          hashTreeDataExtent_ = value;
        } else {
          hashTreeDataExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       */
      public Builder setHashTreeDataExtent(
          chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (hashTreeDataExtentBuilder_ == null) {
          hashTreeDataExtent_ = builderForValue.build();
        } else {
          hashTreeDataExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       */
      public Builder mergeHashTreeDataExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (hashTreeDataExtentBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0) &&
            hashTreeDataExtent_ != null &&
            hashTreeDataExtent_ != chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance()) {
            getHashTreeDataExtentBuilder().mergeFrom(value);
          } else {
            hashTreeDataExtent_ = value;
          }
        } else {
          hashTreeDataExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       */
      public Builder clearHashTreeDataExtent() {
        bitField0_ = (bitField0_ & ~0x00000200);
        hashTreeDataExtent_ = null;
        if (hashTreeDataExtentBuilder_ != null) {
          hashTreeDataExtentBuilder_.dispose();
          hashTreeDataExtentBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder getHashTreeDataExtentBuilder() {
        bitField0_ |= 0x00000200;
        onChanged();
        return getHashTreeDataExtentFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getHashTreeDataExtentOrBuilder() {
        if (hashTreeDataExtentBuilder_ != null) {
          return hashTreeDataExtentBuilder_.getMessageOrBuilder();
        } else {
          return hashTreeDataExtent_ == null ?
              chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeDataExtent_;
        }
      }
      /**
       * <pre>
       * The extent for data covered by verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> 
          getHashTreeDataExtentFieldBuilder() {
        if (hashTreeDataExtentBuilder_ == null) {
          hashTreeDataExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>(
                  getHashTreeDataExtent(),
                  getParentForChildren(),
                  isClean());
          hashTreeDataExtent_ = null;
        }
        return hashTreeDataExtentBuilder_;
      }

      private chromeos_update_engine.UpdateMetadata.Extent hashTreeExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> hashTreeExtentBuilder_;
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       * @return Whether the hashTreeExtent field is set.
       */
      public boolean hasHashTreeExtent() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       * @return The hashTreeExtent.
       */
      public chromeos_update_engine.UpdateMetadata.Extent getHashTreeExtent() {
        if (hashTreeExtentBuilder_ == null) {
          return hashTreeExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeExtent_;
        } else {
          return hashTreeExtentBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       */
      public Builder setHashTreeExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (hashTreeExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          hashTreeExtent_ = value;
        } else {
          hashTreeExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       */
      public Builder setHashTreeExtent(
          chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (hashTreeExtentBuilder_ == null) {
          hashTreeExtent_ = builderForValue.build();
        } else {
          hashTreeExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       */
      public Builder mergeHashTreeExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (hashTreeExtentBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0) &&
            hashTreeExtent_ != null &&
            hashTreeExtent_ != chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance()) {
            getHashTreeExtentBuilder().mergeFrom(value);
          } else {
            hashTreeExtent_ = value;
          }
        } else {
          hashTreeExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       */
      public Builder clearHashTreeExtent() {
        bitField0_ = (bitField0_ & ~0x00000400);
        hashTreeExtent_ = null;
        if (hashTreeExtentBuilder_ != null) {
          hashTreeExtentBuilder_.dispose();
          hashTreeExtentBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder getHashTreeExtentBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getHashTreeExtentFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getHashTreeExtentOrBuilder() {
        if (hashTreeExtentBuilder_ != null) {
          return hashTreeExtentBuilder_.getMessageOrBuilder();
        } else {
          return hashTreeExtent_ == null ?
              chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : hashTreeExtent_;
        }
      }
      /**
       * <pre>
       * The extent to store verity hash tree.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent hash_tree_extent = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> 
          getHashTreeExtentFieldBuilder() {
        if (hashTreeExtentBuilder_ == null) {
          hashTreeExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>(
                  getHashTreeExtent(),
                  getParentForChildren(),
                  isClean());
          hashTreeExtent_ = null;
        }
        return hashTreeExtentBuilder_;
      }

      private java.lang.Object hashTreeAlgorithm_ = "";
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @return Whether the hashTreeAlgorithm field is set.
       */
      public boolean hasHashTreeAlgorithm() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @return The hashTreeAlgorithm.
       */
      public java.lang.String getHashTreeAlgorithm() {
        java.lang.Object ref = hashTreeAlgorithm_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            hashTreeAlgorithm_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @return The bytes for hashTreeAlgorithm.
       */
      public com.google.protobuf.ByteString
          getHashTreeAlgorithmBytes() {
        java.lang.Object ref = hashTreeAlgorithm_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          hashTreeAlgorithm_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @param value The hashTreeAlgorithm to set.
       * @return This builder for chaining.
       */
      public Builder setHashTreeAlgorithm(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        hashTreeAlgorithm_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearHashTreeAlgorithm() {
        hashTreeAlgorithm_ = getDefaultInstance().getHashTreeAlgorithm();
        bitField0_ = (bitField0_ & ~0x00000800);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash algorithm used in verity hash tree.
       * </pre>
       *
       * <code>optional string hash_tree_algorithm = 12;</code>
       * @param value The bytes for hashTreeAlgorithm to set.
       * @return This builder for chaining.
       */
      public Builder setHashTreeAlgorithmBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        hashTreeAlgorithm_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString hashTreeSalt_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The salt used for verity hash tree.
       * </pre>
       *
       * <code>optional bytes hash_tree_salt = 13;</code>
       * @return Whether the hashTreeSalt field is set.
       */
      @java.lang.Override
      public boolean hasHashTreeSalt() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * The salt used for verity hash tree.
       * </pre>
       *
       * <code>optional bytes hash_tree_salt = 13;</code>
       * @return The hashTreeSalt.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getHashTreeSalt() {
        return hashTreeSalt_;
      }
      /**
       * <pre>
       * The salt used for verity hash tree.
       * </pre>
       *
       * <code>optional bytes hash_tree_salt = 13;</code>
       * @param value The hashTreeSalt to set.
       * @return This builder for chaining.
       */
      public Builder setHashTreeSalt(com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        hashTreeSalt_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The salt used for verity hash tree.
       * </pre>
       *
       * <code>optional bytes hash_tree_salt = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearHashTreeSalt() {
        bitField0_ = (bitField0_ & ~0x00001000);
        hashTreeSalt_ = getDefaultInstance().getHashTreeSalt();
        onChanged();
        return this;
      }

      private chromeos_update_engine.UpdateMetadata.Extent fecDataExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> fecDataExtentBuilder_;
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       * @return Whether the fecDataExtent field is set.
       */
      public boolean hasFecDataExtent() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       * @return The fecDataExtent.
       */
      public chromeos_update_engine.UpdateMetadata.Extent getFecDataExtent() {
        if (fecDataExtentBuilder_ == null) {
          return fecDataExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecDataExtent_;
        } else {
          return fecDataExtentBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       */
      public Builder setFecDataExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (fecDataExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          fecDataExtent_ = value;
        } else {
          fecDataExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       */
      public Builder setFecDataExtent(
          chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (fecDataExtentBuilder_ == null) {
          fecDataExtent_ = builderForValue.build();
        } else {
          fecDataExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       */
      public Builder mergeFecDataExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (fecDataExtentBuilder_ == null) {
          if (((bitField0_ & 0x00002000) != 0) &&
            fecDataExtent_ != null &&
            fecDataExtent_ != chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance()) {
            getFecDataExtentBuilder().mergeFrom(value);
          } else {
            fecDataExtent_ = value;
          }
        } else {
          fecDataExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       */
      public Builder clearFecDataExtent() {
        bitField0_ = (bitField0_ & ~0x00002000);
        fecDataExtent_ = null;
        if (fecDataExtentBuilder_ != null) {
          fecDataExtentBuilder_.dispose();
          fecDataExtentBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder getFecDataExtentBuilder() {
        bitField0_ |= 0x00002000;
        onChanged();
        return getFecDataExtentFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getFecDataExtentOrBuilder() {
        if (fecDataExtentBuilder_ != null) {
          return fecDataExtentBuilder_.getMessageOrBuilder();
        } else {
          return fecDataExtent_ == null ?
              chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecDataExtent_;
        }
      }
      /**
       * <pre>
       * The extent for data covered by FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_data_extent = 14;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> 
          getFecDataExtentFieldBuilder() {
        if (fecDataExtentBuilder_ == null) {
          fecDataExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>(
                  getFecDataExtent(),
                  getParentForChildren(),
                  isClean());
          fecDataExtent_ = null;
        }
        return fecDataExtentBuilder_;
      }

      private chromeos_update_engine.UpdateMetadata.Extent fecExtent_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> fecExtentBuilder_;
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       * @return Whether the fecExtent field is set.
       */
      public boolean hasFecExtent() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       * @return The fecExtent.
       */
      public chromeos_update_engine.UpdateMetadata.Extent getFecExtent() {
        if (fecExtentBuilder_ == null) {
          return fecExtent_ == null ? chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecExtent_;
        } else {
          return fecExtentBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       */
      public Builder setFecExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (fecExtentBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          fecExtent_ = value;
        } else {
          fecExtentBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       */
      public Builder setFecExtent(
          chromeos_update_engine.UpdateMetadata.Extent.Builder builderForValue) {
        if (fecExtentBuilder_ == null) {
          fecExtent_ = builderForValue.build();
        } else {
          fecExtentBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       */
      public Builder mergeFecExtent(chromeos_update_engine.UpdateMetadata.Extent value) {
        if (fecExtentBuilder_ == null) {
          if (((bitField0_ & 0x00004000) != 0) &&
            fecExtent_ != null &&
            fecExtent_ != chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance()) {
            getFecExtentBuilder().mergeFrom(value);
          } else {
            fecExtent_ = value;
          }
        } else {
          fecExtentBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       */
      public Builder clearFecExtent() {
        bitField0_ = (bitField0_ & ~0x00004000);
        fecExtent_ = null;
        if (fecExtentBuilder_ != null) {
          fecExtentBuilder_.dispose();
          fecExtentBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       */
      public chromeos_update_engine.UpdateMetadata.Extent.Builder getFecExtentBuilder() {
        bitField0_ |= 0x00004000;
        onChanged();
        return getFecExtentFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ExtentOrBuilder getFecExtentOrBuilder() {
        if (fecExtentBuilder_ != null) {
          return fecExtentBuilder_.getMessageOrBuilder();
        } else {
          return fecExtent_ == null ?
              chromeos_update_engine.UpdateMetadata.Extent.getDefaultInstance() : fecExtent_;
        }
      }
      /**
       * <pre>
       * The extent to store FEC.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.Extent fec_extent = 15;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder> 
          getFecExtentFieldBuilder() {
        if (fecExtentBuilder_ == null) {
          fecExtentBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.Extent, chromeos_update_engine.UpdateMetadata.Extent.Builder, chromeos_update_engine.UpdateMetadata.ExtentOrBuilder>(
                  getFecExtent(),
                  getParentForChildren(),
                  isClean());
          fecExtent_ = null;
        }
        return fecExtentBuilder_;
      }

      private int fecRoots_ = 2;
      /**
       * <pre>
       * The number of FEC roots.
       * </pre>
       *
       * <code>optional uint32 fec_roots = 16 [default = 2];</code>
       * @return Whether the fecRoots field is set.
       */
      @java.lang.Override
      public boolean hasFecRoots() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * The number of FEC roots.
       * </pre>
       *
       * <code>optional uint32 fec_roots = 16 [default = 2];</code>
       * @return The fecRoots.
       */
      @java.lang.Override
      public int getFecRoots() {
        return fecRoots_;
      }
      /**
       * <pre>
       * The number of FEC roots.
       * </pre>
       *
       * <code>optional uint32 fec_roots = 16 [default = 2];</code>
       * @param value The fecRoots to set.
       * @return This builder for chaining.
       */
      public Builder setFecRoots(int value) {
        
        fecRoots_ = value;
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of FEC roots.
       * </pre>
       *
       * <code>optional uint32 fec_roots = 16 [default = 2];</code>
       * @return This builder for chaining.
       */
      public Builder clearFecRoots() {
        bitField0_ = (bitField0_ & ~0x00008000);
        fecRoots_ = 2;
        onChanged();
        return this;
      }

      private java.lang.Object version_ = "";
      /**
       * <pre>
       * Per-partition version used for downgrade detection, added
       * as an effort to support partial updates. For most partitions,
       * this is the build timestamp.
       * </pre>
       *
       * <code>optional string version = 17;</code>
       * @return Whether the version field is set.
       */
      public boolean hasVersion() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <pre>
       * Per-partition version used for downgrade detection, added
       * as an effort to support partial updates. For most partitions,
       * this is the build timestamp.
       * </pre>
       *
       * <code>optional string version = 17;</code>
       * @return The version.
       */
      public java.lang.String getVersion() {
        java.lang.Object ref = version_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            version_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Per-partition version used for downgrade detection, added
       * as an effort to support partial updates. For most partitions,
       * this is the build timestamp.
       * </pre>
       *
       * <code>optional string version = 17;</code>
       * @return The bytes for version.
       */
      public com.google.protobuf.ByteString
          getVersionBytes() {
        java.lang.Object ref = version_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          version_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Per-partition version used for downgrade detection, added
       * as an effort to support partial updates. For most partitions,
       * this is the build timestamp.
       * </pre>
       *
       * <code>optional string version = 17;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        version_ = value;
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Per-partition version used for downgrade detection, added
       * as an effort to support partial updates. For most partitions,
       * this is the build timestamp.
       * </pre>
       *
       * <code>optional string version = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        version_ = getDefaultInstance().getVersion();
        bitField0_ = (bitField0_ & ~0x00010000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Per-partition version used for downgrade detection, added
       * as an effort to support partial updates. For most partitions,
       * this is the build timestamp.
       * </pre>
       *
       * <code>optional string version = 17;</code>
       * @param value The bytes for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        version_ = value;
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }

      private java.util.List<chromeos_update_engine.UpdateMetadata.CowMergeOperation> mergeOperations_ =
        java.util.Collections.emptyList();
      private void ensureMergeOperationsIsMutable() {
        if (!((bitField0_ & 0x00020000) != 0)) {
          mergeOperations_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.CowMergeOperation>(mergeOperations_);
          bitField0_ |= 0x00020000;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.CowMergeOperation, chromeos_update_engine.UpdateMetadata.CowMergeOperation.Builder, chromeos_update_engine.UpdateMetadata.CowMergeOperationOrBuilder> mergeOperationsBuilder_;

      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.CowMergeOperation> getMergeOperationsList() {
        if (mergeOperationsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(mergeOperations_);
        } else {
          return mergeOperationsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public int getMergeOperationsCount() {
        if (mergeOperationsBuilder_ == null) {
          return mergeOperations_.size();
        } else {
          return mergeOperationsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public chromeos_update_engine.UpdateMetadata.CowMergeOperation getMergeOperations(int index) {
        if (mergeOperationsBuilder_ == null) {
          return mergeOperations_.get(index);
        } else {
          return mergeOperationsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public Builder setMergeOperations(
          int index, chromeos_update_engine.UpdateMetadata.CowMergeOperation value) {
        if (mergeOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMergeOperationsIsMutable();
          mergeOperations_.set(index, value);
          onChanged();
        } else {
          mergeOperationsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public Builder setMergeOperations(
          int index, chromeos_update_engine.UpdateMetadata.CowMergeOperation.Builder builderForValue) {
        if (mergeOperationsBuilder_ == null) {
          ensureMergeOperationsIsMutable();
          mergeOperations_.set(index, builderForValue.build());
          onChanged();
        } else {
          mergeOperationsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public Builder addMergeOperations(chromeos_update_engine.UpdateMetadata.CowMergeOperation value) {
        if (mergeOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMergeOperationsIsMutable();
          mergeOperations_.add(value);
          onChanged();
        } else {
          mergeOperationsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public Builder addMergeOperations(
          int index, chromeos_update_engine.UpdateMetadata.CowMergeOperation value) {
        if (mergeOperationsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureMergeOperationsIsMutable();
          mergeOperations_.add(index, value);
          onChanged();
        } else {
          mergeOperationsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public Builder addMergeOperations(
          chromeos_update_engine.UpdateMetadata.CowMergeOperation.Builder builderForValue) {
        if (mergeOperationsBuilder_ == null) {
          ensureMergeOperationsIsMutable();
          mergeOperations_.add(builderForValue.build());
          onChanged();
        } else {
          mergeOperationsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public Builder addMergeOperations(
          int index, chromeos_update_engine.UpdateMetadata.CowMergeOperation.Builder builderForValue) {
        if (mergeOperationsBuilder_ == null) {
          ensureMergeOperationsIsMutable();
          mergeOperations_.add(index, builderForValue.build());
          onChanged();
        } else {
          mergeOperationsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public Builder addAllMergeOperations(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.CowMergeOperation> values) {
        if (mergeOperationsBuilder_ == null) {
          ensureMergeOperationsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, mergeOperations_);
          onChanged();
        } else {
          mergeOperationsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public Builder clearMergeOperations() {
        if (mergeOperationsBuilder_ == null) {
          mergeOperations_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00020000);
          onChanged();
        } else {
          mergeOperationsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public Builder removeMergeOperations(int index) {
        if (mergeOperationsBuilder_ == null) {
          ensureMergeOperationsIsMutable();
          mergeOperations_.remove(index);
          onChanged();
        } else {
          mergeOperationsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public chromeos_update_engine.UpdateMetadata.CowMergeOperation.Builder getMergeOperationsBuilder(
          int index) {
        return getMergeOperationsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public chromeos_update_engine.UpdateMetadata.CowMergeOperationOrBuilder getMergeOperationsOrBuilder(
          int index) {
        if (mergeOperationsBuilder_ == null) {
          return mergeOperations_.get(index);  } else {
          return mergeOperationsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.CowMergeOperationOrBuilder> 
           getMergeOperationsOrBuilderList() {
        if (mergeOperationsBuilder_ != null) {
          return mergeOperationsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(mergeOperations_);
        }
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public chromeos_update_engine.UpdateMetadata.CowMergeOperation.Builder addMergeOperationsBuilder() {
        return getMergeOperationsFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.CowMergeOperation.getDefaultInstance());
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public chromeos_update_engine.UpdateMetadata.CowMergeOperation.Builder addMergeOperationsBuilder(
          int index) {
        return getMergeOperationsFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.CowMergeOperation.getDefaultInstance());
      }
      /**
       * <pre>
       * A sorted list of CowMergeOperation. When writing cow, we can choose to
       * skip writing the raw bytes for these extents. During snapshot merge, the
       * bytes will read from the source partitions instead.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.CowMergeOperation.Builder> 
           getMergeOperationsBuilderList() {
        return getMergeOperationsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.CowMergeOperation, chromeos_update_engine.UpdateMetadata.CowMergeOperation.Builder, chromeos_update_engine.UpdateMetadata.CowMergeOperationOrBuilder> 
          getMergeOperationsFieldBuilder() {
        if (mergeOperationsBuilder_ == null) {
          mergeOperationsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.CowMergeOperation, chromeos_update_engine.UpdateMetadata.CowMergeOperation.Builder, chromeos_update_engine.UpdateMetadata.CowMergeOperationOrBuilder>(
                  mergeOperations_,
                  ((bitField0_ & 0x00020000) != 0),
                  getParentForChildren(),
                  isClean());
          mergeOperations_ = null;
        }
        return mergeOperationsBuilder_;
      }

      private long estimateCowSize_ ;
      /**
       * <pre>
       * Estimated size for COW image. This is used by libsnapshot
       * as a hint. If set to 0, libsnapshot should use alternative
       * methods for estimating size.
       * </pre>
       *
       * <code>optional uint64 estimate_cow_size = 19;</code>
       * @return Whether the estimateCowSize field is set.
       */
      @java.lang.Override
      public boolean hasEstimateCowSize() {
        return ((bitField0_ & 0x00040000) != 0);
      }
      /**
       * <pre>
       * Estimated size for COW image. This is used by libsnapshot
       * as a hint. If set to 0, libsnapshot should use alternative
       * methods for estimating size.
       * </pre>
       *
       * <code>optional uint64 estimate_cow_size = 19;</code>
       * @return The estimateCowSize.
       */
      @java.lang.Override
      public long getEstimateCowSize() {
        return estimateCowSize_;
      }
      /**
       * <pre>
       * Estimated size for COW image. This is used by libsnapshot
       * as a hint. If set to 0, libsnapshot should use alternative
       * methods for estimating size.
       * </pre>
       *
       * <code>optional uint64 estimate_cow_size = 19;</code>
       * @param value The estimateCowSize to set.
       * @return This builder for chaining.
       */
      public Builder setEstimateCowSize(long value) {
        
        estimateCowSize_ = value;
        bitField0_ |= 0x00040000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Estimated size for COW image. This is used by libsnapshot
       * as a hint. If set to 0, libsnapshot should use alternative
       * methods for estimating size.
       * </pre>
       *
       * <code>optional uint64 estimate_cow_size = 19;</code>
       * @return This builder for chaining.
       */
      public Builder clearEstimateCowSize() {
        bitField0_ = (bitField0_ & ~0x00040000);
        estimateCowSize_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.PartitionUpdate)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionUpdate)
    private static final chromeos_update_engine.UpdateMetadata.PartitionUpdate DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.PartitionUpdate();
    }

    public static chromeos_update_engine.UpdateMetadata.PartitionUpdate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<PartitionUpdate>
        PARSER = new com.google.protobuf.AbstractParser<PartitionUpdate>() {
      @java.lang.Override
      public PartitionUpdate parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<PartitionUpdate> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PartitionUpdate> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionUpdate getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DynamicPartitionGroupOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.DynamicPartitionGroup)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * Maximum size of the group. The sum of sizes of all partitions in the group
     * must not exceed the maximum size of the group.
     * </pre>
     *
     * <code>optional uint64 size = 2;</code>
     * @return Whether the size field is set.
     */
    boolean hasSize();
    /**
     * <pre>
     * Maximum size of the group. The sum of sizes of all partitions in the group
     * must not exceed the maximum size of the group.
     * </pre>
     *
     * <code>optional uint64 size = 2;</code>
     * @return The size.
     */
    long getSize();

    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @return A list containing the partitionNames.
     */
    java.util.List<java.lang.String>
        getPartitionNamesList();
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @return The count of partitionNames.
     */
    int getPartitionNamesCount();
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @param index The index of the element to return.
     * @return The partitionNames at the given index.
     */
    java.lang.String getPartitionNames(int index);
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the partitionNames at the given index.
     */
    com.google.protobuf.ByteString
        getPartitionNamesBytes(int index);
  }
  /**
   * Protobuf type {@code chromeos_update_engine.DynamicPartitionGroup}
   */
  public static final class DynamicPartitionGroup extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.DynamicPartitionGroup)
      DynamicPartitionGroupOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DynamicPartitionGroup.newBuilder() to construct.
    private DynamicPartitionGroup(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DynamicPartitionGroup() {
      name_ = "";
      partitionNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new DynamicPartitionGroup();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.class, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder.class);
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Name of the group.
     * </pre>
     *
     * <code>required string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SIZE_FIELD_NUMBER = 2;
    private long size_ = 0L;
    /**
     * <pre>
     * Maximum size of the group. The sum of sizes of all partitions in the group
     * must not exceed the maximum size of the group.
     * </pre>
     *
     * <code>optional uint64 size = 2;</code>
     * @return Whether the size field is set.
     */
    @java.lang.Override
    public boolean hasSize() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Maximum size of the group. The sum of sizes of all partitions in the group
     * must not exceed the maximum size of the group.
     * </pre>
     *
     * <code>optional uint64 size = 2;</code>
     * @return The size.
     */
    @java.lang.Override
    public long getSize() {
      return size_;
    }

    public static final int PARTITION_NAMES_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringList partitionNames_;
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @return A list containing the partitionNames.
     */
    public com.google.protobuf.ProtocolStringList
        getPartitionNamesList() {
      return partitionNames_;
    }
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @return The count of partitionNames.
     */
    public int getPartitionNamesCount() {
      return partitionNames_.size();
    }
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @param index The index of the element to return.
     * @return The partitionNames at the given index.
     */
    public java.lang.String getPartitionNames(int index) {
      return partitionNames_.get(index);
    }
    /**
     * <pre>
     * A list of partitions that belong to the group.
     * </pre>
     *
     * <code>repeated string partition_names = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the partitionNames at the given index.
     */
    public com.google.protobuf.ByteString
        getPartitionNamesBytes(int index) {
      return partitionNames_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      if (!hasName()) {
        memoizedIsInitialized = 0;
        return false;
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(2, size_);
      }
      for (int i = 0; i < partitionNames_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, partitionNames_.getRaw(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, size_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < partitionNames_.size(); i++) {
          dataSize += computeStringSizeNoTag(partitionNames_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getPartitionNamesList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup other = (chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasSize() != other.hasSize()) return false;
      if (hasSize()) {
        if (getSize()
            != other.getSize()) return false;
      }
      if (!getPartitionNamesList()
          .equals(other.getPartitionNamesList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasSize()) {
        hash = (37 * hash) + SIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSize());
      }
      if (getPartitionNamesCount() > 0) {
        hash = (37 * hash) + PARTITION_NAMES_FIELD_NUMBER;
        hash = (53 * hash) + getPartitionNamesList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chromeos_update_engine.DynamicPartitionGroup}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.DynamicPartitionGroup)
        chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.class, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        size_ = 0L;
        partitionNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup build() {
        chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup buildPartial() {
        chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup result = new chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup result) {
        if (((bitField0_ & 0x00000004) != 0)) {
          partitionNames_ = partitionNames_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.partitionNames_ = partitionNames_;
      }

      private void buildPartial0(chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.size_ = size_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup other) {
        if (other == chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasSize()) {
          setSize(other.getSize());
        }
        if (!other.partitionNames_.isEmpty()) {
          if (partitionNames_.isEmpty()) {
            partitionNames_ = other.partitionNames_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensurePartitionNamesIsMutable();
            partitionNames_.addAll(other.partitionNames_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        if (!hasName()) {
          return false;
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                size_ = input.readUInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 26: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensurePartitionNamesIsMutable();
                partitionNames_.add(bs);
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Name of the group.
       * </pre>
       *
       * <code>required string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private long size_ ;
      /**
       * <pre>
       * Maximum size of the group. The sum of sizes of all partitions in the group
       * must not exceed the maximum size of the group.
       * </pre>
       *
       * <code>optional uint64 size = 2;</code>
       * @return Whether the size field is set.
       */
      @java.lang.Override
      public boolean hasSize() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Maximum size of the group. The sum of sizes of all partitions in the group
       * must not exceed the maximum size of the group.
       * </pre>
       *
       * <code>optional uint64 size = 2;</code>
       * @return The size.
       */
      @java.lang.Override
      public long getSize() {
        return size_;
      }
      /**
       * <pre>
       * Maximum size of the group. The sum of sizes of all partitions in the group
       * must not exceed the maximum size of the group.
       * </pre>
       *
       * <code>optional uint64 size = 2;</code>
       * @param value The size to set.
       * @return This builder for chaining.
       */
      public Builder setSize(long value) {
        
        size_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum size of the group. The sum of sizes of all partitions in the group
       * must not exceed the maximum size of the group.
       * </pre>
       *
       * <code>optional uint64 size = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSize() {
        bitField0_ = (bitField0_ & ~0x00000002);
        size_ = 0L;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList partitionNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensurePartitionNamesIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          partitionNames_ = new com.google.protobuf.LazyStringArrayList(partitionNames_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @return A list containing the partitionNames.
       */
      public com.google.protobuf.ProtocolStringList
          getPartitionNamesList() {
        return partitionNames_.getUnmodifiableView();
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @return The count of partitionNames.
       */
      public int getPartitionNamesCount() {
        return partitionNames_.size();
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param index The index of the element to return.
       * @return The partitionNames at the given index.
       */
      public java.lang.String getPartitionNames(int index) {
        return partitionNames_.get(index);
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param index The index of the value to return.
       * @return The bytes of the partitionNames at the given index.
       */
      public com.google.protobuf.ByteString
          getPartitionNamesBytes(int index) {
        return partitionNames_.getByteString(index);
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param index The index to set the value at.
       * @param value The partitionNames to set.
       * @return This builder for chaining.
       */
      public Builder setPartitionNames(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensurePartitionNamesIsMutable();
        partitionNames_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param value The partitionNames to add.
       * @return This builder for chaining.
       */
      public Builder addPartitionNames(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensurePartitionNamesIsMutable();
        partitionNames_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param values The partitionNames to add.
       * @return This builder for chaining.
       */
      public Builder addAllPartitionNames(
          java.lang.Iterable<java.lang.String> values) {
        ensurePartitionNamesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, partitionNames_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPartitionNames() {
        partitionNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A list of partitions that belong to the group.
       * </pre>
       *
       * <code>repeated string partition_names = 3;</code>
       * @param value The bytes of the partitionNames to add.
       * @return This builder for chaining.
       */
      public Builder addPartitionNamesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensurePartitionNamesIsMutable();
        partitionNames_.add(value);
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.DynamicPartitionGroup)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionGroup)
    private static final chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup();
    }

    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<DynamicPartitionGroup>
        PARSER = new com.google.protobuf.AbstractParser<DynamicPartitionGroup>() {
      @java.lang.Override
      public DynamicPartitionGroup parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DynamicPartitionGroup> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DynamicPartitionGroup> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VABCFeatureSetOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.VABCFeatureSet)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional bool threaded = 1;</code>
     * @return Whether the threaded field is set.
     */
    boolean hasThreaded();
    /**
     * <code>optional bool threaded = 1;</code>
     * @return The threaded.
     */
    boolean getThreaded();

    /**
     * <code>optional bool batch_writes = 2;</code>
     * @return Whether the batchWrites field is set.
     */
    boolean hasBatchWrites();
    /**
     * <code>optional bool batch_writes = 2;</code>
     * @return The batchWrites.
     */
    boolean getBatchWrites();
  }
  /**
   * Protobuf type {@code chromeos_update_engine.VABCFeatureSet}
   */
  public static final class VABCFeatureSet extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.VABCFeatureSet)
      VABCFeatureSetOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use VABCFeatureSet.newBuilder() to construct.
    private VABCFeatureSet(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private VABCFeatureSet() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new VABCFeatureSet();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_VABCFeatureSet_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_VABCFeatureSet_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.VABCFeatureSet.class, chromeos_update_engine.UpdateMetadata.VABCFeatureSet.Builder.class);
    }

    private int bitField0_;
    public static final int THREADED_FIELD_NUMBER = 1;
    private boolean threaded_ = false;
    /**
     * <code>optional bool threaded = 1;</code>
     * @return Whether the threaded field is set.
     */
    @java.lang.Override
    public boolean hasThreaded() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional bool threaded = 1;</code>
     * @return The threaded.
     */
    @java.lang.Override
    public boolean getThreaded() {
      return threaded_;
    }

    public static final int BATCH_WRITES_FIELD_NUMBER = 2;
    private boolean batchWrites_ = false;
    /**
     * <code>optional bool batch_writes = 2;</code>
     * @return Whether the batchWrites field is set.
     */
    @java.lang.Override
    public boolean hasBatchWrites() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional bool batch_writes = 2;</code>
     * @return The batchWrites.
     */
    @java.lang.Override
    public boolean getBatchWrites() {
      return batchWrites_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBool(1, threaded_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBool(2, batchWrites_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, threaded_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, batchWrites_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.VABCFeatureSet)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.VABCFeatureSet other = (chromeos_update_engine.UpdateMetadata.VABCFeatureSet) obj;

      if (hasThreaded() != other.hasThreaded()) return false;
      if (hasThreaded()) {
        if (getThreaded()
            != other.getThreaded()) return false;
      }
      if (hasBatchWrites() != other.hasBatchWrites()) return false;
      if (hasBatchWrites()) {
        if (getBatchWrites()
            != other.getBatchWrites()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasThreaded()) {
        hash = (37 * hash) + THREADED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getThreaded());
      }
      if (hasBatchWrites()) {
        hash = (37 * hash) + BATCH_WRITES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getBatchWrites());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.VABCFeatureSet parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.VABCFeatureSet parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.VABCFeatureSet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.VABCFeatureSet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.VABCFeatureSet parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.VABCFeatureSet parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.VABCFeatureSet parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.VABCFeatureSet parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.VABCFeatureSet parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.VABCFeatureSet parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.VABCFeatureSet parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.VABCFeatureSet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.VABCFeatureSet prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chromeos_update_engine.VABCFeatureSet}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.VABCFeatureSet)
        chromeos_update_engine.UpdateMetadata.VABCFeatureSetOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_VABCFeatureSet_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_VABCFeatureSet_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.VABCFeatureSet.class, chromeos_update_engine.UpdateMetadata.VABCFeatureSet.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.VABCFeatureSet.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        threaded_ = false;
        batchWrites_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_VABCFeatureSet_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.VABCFeatureSet getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.VABCFeatureSet.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.VABCFeatureSet build() {
        chromeos_update_engine.UpdateMetadata.VABCFeatureSet result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.VABCFeatureSet buildPartial() {
        chromeos_update_engine.UpdateMetadata.VABCFeatureSet result = new chromeos_update_engine.UpdateMetadata.VABCFeatureSet(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(chromeos_update_engine.UpdateMetadata.VABCFeatureSet result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.threaded_ = threaded_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.batchWrites_ = batchWrites_;
          to_bitField0_ |= 0x00000002;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.VABCFeatureSet) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.VABCFeatureSet)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.VABCFeatureSet other) {
        if (other == chromeos_update_engine.UpdateMetadata.VABCFeatureSet.getDefaultInstance()) return this;
        if (other.hasThreaded()) {
          setThreaded(other.getThreaded());
        }
        if (other.hasBatchWrites()) {
          setBatchWrites(other.getBatchWrites());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                threaded_ = input.readBool();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                batchWrites_ = input.readBool();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private boolean threaded_ ;
      /**
       * <code>optional bool threaded = 1;</code>
       * @return Whether the threaded field is set.
       */
      @java.lang.Override
      public boolean hasThreaded() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional bool threaded = 1;</code>
       * @return The threaded.
       */
      @java.lang.Override
      public boolean getThreaded() {
        return threaded_;
      }
      /**
       * <code>optional bool threaded = 1;</code>
       * @param value The threaded to set.
       * @return This builder for chaining.
       */
      public Builder setThreaded(boolean value) {
        
        threaded_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool threaded = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearThreaded() {
        bitField0_ = (bitField0_ & ~0x00000001);
        threaded_ = false;
        onChanged();
        return this;
      }

      private boolean batchWrites_ ;
      /**
       * <code>optional bool batch_writes = 2;</code>
       * @return Whether the batchWrites field is set.
       */
      @java.lang.Override
      public boolean hasBatchWrites() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional bool batch_writes = 2;</code>
       * @return The batchWrites.
       */
      @java.lang.Override
      public boolean getBatchWrites() {
        return batchWrites_;
      }
      /**
       * <code>optional bool batch_writes = 2;</code>
       * @param value The batchWrites to set.
       * @return This builder for chaining.
       */
      public Builder setBatchWrites(boolean value) {
        
        batchWrites_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool batch_writes = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearBatchWrites() {
        bitField0_ = (bitField0_ & ~0x00000002);
        batchWrites_ = false;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.VABCFeatureSet)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.VABCFeatureSet)
    private static final chromeos_update_engine.UpdateMetadata.VABCFeatureSet DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.VABCFeatureSet();
    }

    public static chromeos_update_engine.UpdateMetadata.VABCFeatureSet getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<VABCFeatureSet>
        PARSER = new com.google.protobuf.AbstractParser<VABCFeatureSet>() {
      @java.lang.Override
      public VABCFeatureSet parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<VABCFeatureSet> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<VABCFeatureSet> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.VABCFeatureSet getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DynamicPartitionMetadataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.DynamicPartitionMetadata)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup> 
        getGroupsList();
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup getGroups(int index);
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    int getGroupsCount();
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder> 
        getGroupsOrBuilderList();
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder getGroupsOrBuilder(
        int index);

    /**
     * <pre>
     * Whether dynamic partitions have snapshots during the update. If this is
     * set to true, the update_engine daemon creates snapshots for all dynamic
     * partitions if possible. If this is unset, the update_engine daemon MUST
     * NOT create snapshots for dynamic partitions.
     * </pre>
     *
     * <code>optional bool snapshot_enabled = 2;</code>
     * @return Whether the snapshotEnabled field is set.
     */
    boolean hasSnapshotEnabled();
    /**
     * <pre>
     * Whether dynamic partitions have snapshots during the update. If this is
     * set to true, the update_engine daemon creates snapshots for all dynamic
     * partitions if possible. If this is unset, the update_engine daemon MUST
     * NOT create snapshots for dynamic partitions.
     * </pre>
     *
     * <code>optional bool snapshot_enabled = 2;</code>
     * @return The snapshotEnabled.
     */
    boolean getSnapshotEnabled();

    /**
     * <pre>
     * If this is set to false, update_engine should not use VABC regardless. If
     * this is set to true, update_engine may choose to use VABC if device
     * supports it, but not guaranteed.
     * VABC stands for Virtual AB Compression
     * </pre>
     *
     * <code>optional bool vabc_enabled = 3;</code>
     * @return Whether the vabcEnabled field is set.
     */
    boolean hasVabcEnabled();
    /**
     * <pre>
     * If this is set to false, update_engine should not use VABC regardless. If
     * this is set to true, update_engine may choose to use VABC if device
     * supports it, but not guaranteed.
     * VABC stands for Virtual AB Compression
     * </pre>
     *
     * <code>optional bool vabc_enabled = 3;</code>
     * @return The vabcEnabled.
     */
    boolean getVabcEnabled();

    /**
     * <pre>
     * The compression algorithm used by VABC. Available ones are "gz", "brotli".
     * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
     * as this parameter is ultimated forwarded to libsnapshot's CowWriter
     * </pre>
     *
     * <code>optional string vabc_compression_param = 4;</code>
     * @return Whether the vabcCompressionParam field is set.
     */
    boolean hasVabcCompressionParam();
    /**
     * <pre>
     * The compression algorithm used by VABC. Available ones are "gz", "brotli".
     * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
     * as this parameter is ultimated forwarded to libsnapshot's CowWriter
     * </pre>
     *
     * <code>optional string vabc_compression_param = 4;</code>
     * @return The vabcCompressionParam.
     */
    java.lang.String getVabcCompressionParam();
    /**
     * <pre>
     * The compression algorithm used by VABC. Available ones are "gz", "brotli".
     * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
     * as this parameter is ultimated forwarded to libsnapshot's CowWriter
     * </pre>
     *
     * <code>optional string vabc_compression_param = 4;</code>
     * @return The bytes for vabcCompressionParam.
     */
    com.google.protobuf.ByteString
        getVabcCompressionParamBytes();

    /**
     * <pre>
     * COW version used by VABC. The represents the major version in the COW
     * header
     * </pre>
     *
     * <code>optional uint32 cow_version = 5;</code>
     * @return Whether the cowVersion field is set.
     */
    boolean hasCowVersion();
    /**
     * <pre>
     * COW version used by VABC. The represents the major version in the COW
     * header
     * </pre>
     *
     * <code>optional uint32 cow_version = 5;</code>
     * @return The cowVersion.
     */
    int getCowVersion();

    /**
     * <pre>
     * A collection of knobs to tune Virtual AB Compression
     * </pre>
     *
     * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
     * @return Whether the vabcFeatureSet field is set.
     */
    boolean hasVabcFeatureSet();
    /**
     * <pre>
     * A collection of knobs to tune Virtual AB Compression
     * </pre>
     *
     * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
     * @return The vabcFeatureSet.
     */
    chromeos_update_engine.UpdateMetadata.VABCFeatureSet getVabcFeatureSet();
    /**
     * <pre>
     * A collection of knobs to tune Virtual AB Compression
     * </pre>
     *
     * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
     */
    chromeos_update_engine.UpdateMetadata.VABCFeatureSetOrBuilder getVabcFeatureSetOrBuilder();
  }
  /**
   * <pre>
   * Metadata related to all dynamic partitions.
   * </pre>
   *
   * Protobuf type {@code chromeos_update_engine.DynamicPartitionMetadata}
   */
  public static final class DynamicPartitionMetadata extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.DynamicPartitionMetadata)
      DynamicPartitionMetadataOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DynamicPartitionMetadata.newBuilder() to construct.
    private DynamicPartitionMetadata(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DynamicPartitionMetadata() {
      groups_ = java.util.Collections.emptyList();
      vabcCompressionParam_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new DynamicPartitionMetadata();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.class, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder.class);
    }

    private int bitField0_;
    public static final int GROUPS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup> groups_;
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup> getGroupsList() {
      return groups_;
    }
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder> 
        getGroupsOrBuilderList() {
      return groups_;
    }
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    @java.lang.Override
    public int getGroupsCount() {
      return groups_.size();
    }
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup getGroups(int index) {
      return groups_.get(index);
    }
    /**
     * <pre>
     * All updatable groups present in |partitions| of this DeltaArchiveManifest.
     * - If an updatable group is on the device but not in the manifest, it is
     *   not updated. Hence, the group will not be resized, and partitions cannot
     *   be added to or removed from the group.
     * - If an updatable group is in the manifest but not on the device, the group
     *   is added to the device.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder getGroupsOrBuilder(
        int index) {
      return groups_.get(index);
    }

    public static final int SNAPSHOT_ENABLED_FIELD_NUMBER = 2;
    private boolean snapshotEnabled_ = false;
    /**
     * <pre>
     * Whether dynamic partitions have snapshots during the update. If this is
     * set to true, the update_engine daemon creates snapshots for all dynamic
     * partitions if possible. If this is unset, the update_engine daemon MUST
     * NOT create snapshots for dynamic partitions.
     * </pre>
     *
     * <code>optional bool snapshot_enabled = 2;</code>
     * @return Whether the snapshotEnabled field is set.
     */
    @java.lang.Override
    public boolean hasSnapshotEnabled() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Whether dynamic partitions have snapshots during the update. If this is
     * set to true, the update_engine daemon creates snapshots for all dynamic
     * partitions if possible. If this is unset, the update_engine daemon MUST
     * NOT create snapshots for dynamic partitions.
     * </pre>
     *
     * <code>optional bool snapshot_enabled = 2;</code>
     * @return The snapshotEnabled.
     */
    @java.lang.Override
    public boolean getSnapshotEnabled() {
      return snapshotEnabled_;
    }

    public static final int VABC_ENABLED_FIELD_NUMBER = 3;
    private boolean vabcEnabled_ = false;
    /**
     * <pre>
     * If this is set to false, update_engine should not use VABC regardless. If
     * this is set to true, update_engine may choose to use VABC if device
     * supports it, but not guaranteed.
     * VABC stands for Virtual AB Compression
     * </pre>
     *
     * <code>optional bool vabc_enabled = 3;</code>
     * @return Whether the vabcEnabled field is set.
     */
    @java.lang.Override
    public boolean hasVabcEnabled() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * If this is set to false, update_engine should not use VABC regardless. If
     * this is set to true, update_engine may choose to use VABC if device
     * supports it, but not guaranteed.
     * VABC stands for Virtual AB Compression
     * </pre>
     *
     * <code>optional bool vabc_enabled = 3;</code>
     * @return The vabcEnabled.
     */
    @java.lang.Override
    public boolean getVabcEnabled() {
      return vabcEnabled_;
    }

    public static final int VABC_COMPRESSION_PARAM_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private volatile java.lang.Object vabcCompressionParam_ = "";
    /**
     * <pre>
     * The compression algorithm used by VABC. Available ones are "gz", "brotli".
     * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
     * as this parameter is ultimated forwarded to libsnapshot's CowWriter
     * </pre>
     *
     * <code>optional string vabc_compression_param = 4;</code>
     * @return Whether the vabcCompressionParam field is set.
     */
    @java.lang.Override
    public boolean hasVabcCompressionParam() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The compression algorithm used by VABC. Available ones are "gz", "brotli".
     * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
     * as this parameter is ultimated forwarded to libsnapshot's CowWriter
     * </pre>
     *
     * <code>optional string vabc_compression_param = 4;</code>
     * @return The vabcCompressionParam.
     */
    @java.lang.Override
    public java.lang.String getVabcCompressionParam() {
      java.lang.Object ref = vabcCompressionParam_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          vabcCompressionParam_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * The compression algorithm used by VABC. Available ones are "gz", "brotli".
     * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
     * as this parameter is ultimated forwarded to libsnapshot's CowWriter
     * </pre>
     *
     * <code>optional string vabc_compression_param = 4;</code>
     * @return The bytes for vabcCompressionParam.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVabcCompressionParamBytes() {
      java.lang.Object ref = vabcCompressionParam_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        vabcCompressionParam_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int COW_VERSION_FIELD_NUMBER = 5;
    private int cowVersion_ = 0;
    /**
     * <pre>
     * COW version used by VABC. The represents the major version in the COW
     * header
     * </pre>
     *
     * <code>optional uint32 cow_version = 5;</code>
     * @return Whether the cowVersion field is set.
     */
    @java.lang.Override
    public boolean hasCowVersion() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * COW version used by VABC. The represents the major version in the COW
     * header
     * </pre>
     *
     * <code>optional uint32 cow_version = 5;</code>
     * @return The cowVersion.
     */
    @java.lang.Override
    public int getCowVersion() {
      return cowVersion_;
    }

    public static final int VABC_FEATURE_SET_FIELD_NUMBER = 6;
    private chromeos_update_engine.UpdateMetadata.VABCFeatureSet vabcFeatureSet_;
    /**
     * <pre>
     * A collection of knobs to tune Virtual AB Compression
     * </pre>
     *
     * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
     * @return Whether the vabcFeatureSet field is set.
     */
    @java.lang.Override
    public boolean hasVabcFeatureSet() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * A collection of knobs to tune Virtual AB Compression
     * </pre>
     *
     * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
     * @return The vabcFeatureSet.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.VABCFeatureSet getVabcFeatureSet() {
      return vabcFeatureSet_ == null ? chromeos_update_engine.UpdateMetadata.VABCFeatureSet.getDefaultInstance() : vabcFeatureSet_;
    }
    /**
     * <pre>
     * A collection of knobs to tune Virtual AB Compression
     * </pre>
     *
     * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.VABCFeatureSetOrBuilder getVabcFeatureSetOrBuilder() {
      return vabcFeatureSet_ == null ? chromeos_update_engine.UpdateMetadata.VABCFeatureSet.getDefaultInstance() : vabcFeatureSet_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getGroupsCount(); i++) {
        if (!getGroups(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < groups_.size(); i++) {
        output.writeMessage(1, groups_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBool(2, snapshotEnabled_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBool(3, vabcEnabled_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, vabcCompressionParam_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt32(5, cowVersion_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(6, getVabcFeatureSet());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < groups_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, groups_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, snapshotEnabled_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, vabcEnabled_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, vabcCompressionParam_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(5, cowVersion_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getVabcFeatureSet());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata other = (chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata) obj;

      if (!getGroupsList()
          .equals(other.getGroupsList())) return false;
      if (hasSnapshotEnabled() != other.hasSnapshotEnabled()) return false;
      if (hasSnapshotEnabled()) {
        if (getSnapshotEnabled()
            != other.getSnapshotEnabled()) return false;
      }
      if (hasVabcEnabled() != other.hasVabcEnabled()) return false;
      if (hasVabcEnabled()) {
        if (getVabcEnabled()
            != other.getVabcEnabled()) return false;
      }
      if (hasVabcCompressionParam() != other.hasVabcCompressionParam()) return false;
      if (hasVabcCompressionParam()) {
        if (!getVabcCompressionParam()
            .equals(other.getVabcCompressionParam())) return false;
      }
      if (hasCowVersion() != other.hasCowVersion()) return false;
      if (hasCowVersion()) {
        if (getCowVersion()
            != other.getCowVersion()) return false;
      }
      if (hasVabcFeatureSet() != other.hasVabcFeatureSet()) return false;
      if (hasVabcFeatureSet()) {
        if (!getVabcFeatureSet()
            .equals(other.getVabcFeatureSet())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getGroupsCount() > 0) {
        hash = (37 * hash) + GROUPS_FIELD_NUMBER;
        hash = (53 * hash) + getGroupsList().hashCode();
      }
      if (hasSnapshotEnabled()) {
        hash = (37 * hash) + SNAPSHOT_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSnapshotEnabled());
      }
      if (hasVabcEnabled()) {
        hash = (37 * hash) + VABC_ENABLED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getVabcEnabled());
      }
      if (hasVabcCompressionParam()) {
        hash = (37 * hash) + VABC_COMPRESSION_PARAM_FIELD_NUMBER;
        hash = (53 * hash) + getVabcCompressionParam().hashCode();
      }
      if (hasCowVersion()) {
        hash = (37 * hash) + COW_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getCowVersion();
      }
      if (hasVabcFeatureSet()) {
        hash = (37 * hash) + VABC_FEATURE_SET_FIELD_NUMBER;
        hash = (53 * hash) + getVabcFeatureSet().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * Protobuf type {@code chromeos_update_engine.DynamicPartitionMetadata}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.DynamicPartitionMetadata)
        chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadataOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.class, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getGroupsFieldBuilder();
          getVabcFeatureSetFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (groupsBuilder_ == null) {
          groups_ = java.util.Collections.emptyList();
        } else {
          groups_ = null;
          groupsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        snapshotEnabled_ = false;
        vabcEnabled_ = false;
        vabcCompressionParam_ = "";
        cowVersion_ = 0;
        vabcFeatureSet_ = null;
        if (vabcFeatureSetBuilder_ != null) {
          vabcFeatureSetBuilder_.dispose();
          vabcFeatureSetBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata build() {
        chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata buildPartial() {
        chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata result = new chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata result) {
        if (groupsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            groups_ = java.util.Collections.unmodifiableList(groups_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.groups_ = groups_;
        } else {
          result.groups_ = groupsBuilder_.build();
        }
      }

      private void buildPartial0(chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.snapshotEnabled_ = snapshotEnabled_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.vabcEnabled_ = vabcEnabled_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.vabcCompressionParam_ = vabcCompressionParam_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.cowVersion_ = cowVersion_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.vabcFeatureSet_ = vabcFeatureSetBuilder_ == null
              ? vabcFeatureSet_
              : vabcFeatureSetBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata other) {
        if (other == chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.getDefaultInstance()) return this;
        if (groupsBuilder_ == null) {
          if (!other.groups_.isEmpty()) {
            if (groups_.isEmpty()) {
              groups_ = other.groups_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureGroupsIsMutable();
              groups_.addAll(other.groups_);
            }
            onChanged();
          }
        } else {
          if (!other.groups_.isEmpty()) {
            if (groupsBuilder_.isEmpty()) {
              groupsBuilder_.dispose();
              groupsBuilder_ = null;
              groups_ = other.groups_;
              bitField0_ = (bitField0_ & ~0x00000001);
              groupsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getGroupsFieldBuilder() : null;
            } else {
              groupsBuilder_.addAllMessages(other.groups_);
            }
          }
        }
        if (other.hasSnapshotEnabled()) {
          setSnapshotEnabled(other.getSnapshotEnabled());
        }
        if (other.hasVabcEnabled()) {
          setVabcEnabled(other.getVabcEnabled());
        }
        if (other.hasVabcCompressionParam()) {
          vabcCompressionParam_ = other.vabcCompressionParam_;
          bitField0_ |= 0x00000008;
          onChanged();
        }
        if (other.hasCowVersion()) {
          setCowVersion(other.getCowVersion());
        }
        if (other.hasVabcFeatureSet()) {
          mergeVabcFeatureSet(other.getVabcFeatureSet());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        for (int i = 0; i < getGroupsCount(); i++) {
          if (!getGroups(i).isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup m =
                    input.readMessage(
                        chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.PARSER,
                        extensionRegistry);
                if (groupsBuilder_ == null) {
                  ensureGroupsIsMutable();
                  groups_.add(m);
                } else {
                  groupsBuilder_.addMessage(m);
                }
                break;
              } // case 10
              case 16: {
                snapshotEnabled_ = input.readBool();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                vabcEnabled_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 34: {
                vabcCompressionParam_ = input.readBytes();
                bitField0_ |= 0x00000008;
                break;
              } // case 34
              case 40: {
                cowVersion_ = input.readUInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 50: {
                input.readMessage(
                    getVabcFeatureSetFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000020;
                break;
              } // case 50
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup> groups_ =
        java.util.Collections.emptyList();
      private void ensureGroupsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          groups_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup>(groups_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder> groupsBuilder_;

      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup> getGroupsList() {
        if (groupsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(groups_);
        } else {
          return groupsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public int getGroupsCount() {
        if (groupsBuilder_ == null) {
          return groups_.size();
        } else {
          return groupsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup getGroups(int index) {
        if (groupsBuilder_ == null) {
          return groups_.get(index);
        } else {
          return groupsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder setGroups(
          int index, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup value) {
        if (groupsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGroupsIsMutable();
          groups_.set(index, value);
          onChanged();
        } else {
          groupsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder setGroups(
          int index, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder builderForValue) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.set(index, builderForValue.build());
          onChanged();
        } else {
          groupsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addGroups(chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup value) {
        if (groupsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGroupsIsMutable();
          groups_.add(value);
          onChanged();
        } else {
          groupsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addGroups(
          int index, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup value) {
        if (groupsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureGroupsIsMutable();
          groups_.add(index, value);
          onChanged();
        } else {
          groupsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addGroups(
          chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder builderForValue) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.add(builderForValue.build());
          onChanged();
        } else {
          groupsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addGroups(
          int index, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder builderForValue) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.add(index, builderForValue.build());
          onChanged();
        } else {
          groupsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder addAllGroups(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup> values) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, groups_);
          onChanged();
        } else {
          groupsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder clearGroups() {
        if (groupsBuilder_ == null) {
          groups_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          groupsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public Builder removeGroups(int index) {
        if (groupsBuilder_ == null) {
          ensureGroupsIsMutable();
          groups_.remove(index);
          onChanged();
        } else {
          groupsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder getGroupsBuilder(
          int index) {
        return getGroupsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder getGroupsOrBuilder(
          int index) {
        if (groupsBuilder_ == null) {
          return groups_.get(index);  } else {
          return groupsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder> 
           getGroupsOrBuilderList() {
        if (groupsBuilder_ != null) {
          return groupsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(groups_);
        }
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder addGroupsBuilder() {
        return getGroupsFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.getDefaultInstance());
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder addGroupsBuilder(
          int index) {
        return getGroupsFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.getDefaultInstance());
      }
      /**
       * <pre>
       * All updatable groups present in |partitions| of this DeltaArchiveManifest.
       * - If an updatable group is on the device but not in the manifest, it is
       *   not updated. Hence, the group will not be resized, and partitions cannot
       *   be added to or removed from the group.
       * - If an updatable group is in the manifest but not on the device, the group
       *   is added to the device.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder> 
           getGroupsBuilderList() {
        return getGroupsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder> 
          getGroupsFieldBuilder() {
        if (groupsBuilder_ == null) {
          groupsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroup.Builder, chromeos_update_engine.UpdateMetadata.DynamicPartitionGroupOrBuilder>(
                  groups_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          groups_ = null;
        }
        return groupsBuilder_;
      }

      private boolean snapshotEnabled_ ;
      /**
       * <pre>
       * Whether dynamic partitions have snapshots during the update. If this is
       * set to true, the update_engine daemon creates snapshots for all dynamic
       * partitions if possible. If this is unset, the update_engine daemon MUST
       * NOT create snapshots for dynamic partitions.
       * </pre>
       *
       * <code>optional bool snapshot_enabled = 2;</code>
       * @return Whether the snapshotEnabled field is set.
       */
      @java.lang.Override
      public boolean hasSnapshotEnabled() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Whether dynamic partitions have snapshots during the update. If this is
       * set to true, the update_engine daemon creates snapshots for all dynamic
       * partitions if possible. If this is unset, the update_engine daemon MUST
       * NOT create snapshots for dynamic partitions.
       * </pre>
       *
       * <code>optional bool snapshot_enabled = 2;</code>
       * @return The snapshotEnabled.
       */
      @java.lang.Override
      public boolean getSnapshotEnabled() {
        return snapshotEnabled_;
      }
      /**
       * <pre>
       * Whether dynamic partitions have snapshots during the update. If this is
       * set to true, the update_engine daemon creates snapshots for all dynamic
       * partitions if possible. If this is unset, the update_engine daemon MUST
       * NOT create snapshots for dynamic partitions.
       * </pre>
       *
       * <code>optional bool snapshot_enabled = 2;</code>
       * @param value The snapshotEnabled to set.
       * @return This builder for chaining.
       */
      public Builder setSnapshotEnabled(boolean value) {
        
        snapshotEnabled_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether dynamic partitions have snapshots during the update. If this is
       * set to true, the update_engine daemon creates snapshots for all dynamic
       * partitions if possible. If this is unset, the update_engine daemon MUST
       * NOT create snapshots for dynamic partitions.
       * </pre>
       *
       * <code>optional bool snapshot_enabled = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSnapshotEnabled() {
        bitField0_ = (bitField0_ & ~0x00000002);
        snapshotEnabled_ = false;
        onChanged();
        return this;
      }

      private boolean vabcEnabled_ ;
      /**
       * <pre>
       * If this is set to false, update_engine should not use VABC regardless. If
       * this is set to true, update_engine may choose to use VABC if device
       * supports it, but not guaranteed.
       * VABC stands for Virtual AB Compression
       * </pre>
       *
       * <code>optional bool vabc_enabled = 3;</code>
       * @return Whether the vabcEnabled field is set.
       */
      @java.lang.Override
      public boolean hasVabcEnabled() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * If this is set to false, update_engine should not use VABC regardless. If
       * this is set to true, update_engine may choose to use VABC if device
       * supports it, but not guaranteed.
       * VABC stands for Virtual AB Compression
       * </pre>
       *
       * <code>optional bool vabc_enabled = 3;</code>
       * @return The vabcEnabled.
       */
      @java.lang.Override
      public boolean getVabcEnabled() {
        return vabcEnabled_;
      }
      /**
       * <pre>
       * If this is set to false, update_engine should not use VABC regardless. If
       * this is set to true, update_engine may choose to use VABC if device
       * supports it, but not guaranteed.
       * VABC stands for Virtual AB Compression
       * </pre>
       *
       * <code>optional bool vabc_enabled = 3;</code>
       * @param value The vabcEnabled to set.
       * @return This builder for chaining.
       */
      public Builder setVabcEnabled(boolean value) {
        
        vabcEnabled_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If this is set to false, update_engine should not use VABC regardless. If
       * this is set to true, update_engine may choose to use VABC if device
       * supports it, but not guaranteed.
       * VABC stands for Virtual AB Compression
       * </pre>
       *
       * <code>optional bool vabc_enabled = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearVabcEnabled() {
        bitField0_ = (bitField0_ & ~0x00000004);
        vabcEnabled_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object vabcCompressionParam_ = "";
      /**
       * <pre>
       * The compression algorithm used by VABC. Available ones are "gz", "brotli".
       * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
       * as this parameter is ultimated forwarded to libsnapshot's CowWriter
       * </pre>
       *
       * <code>optional string vabc_compression_param = 4;</code>
       * @return Whether the vabcCompressionParam field is set.
       */
      public boolean hasVabcCompressionParam() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The compression algorithm used by VABC. Available ones are "gz", "brotli".
       * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
       * as this parameter is ultimated forwarded to libsnapshot's CowWriter
       * </pre>
       *
       * <code>optional string vabc_compression_param = 4;</code>
       * @return The vabcCompressionParam.
       */
      public java.lang.String getVabcCompressionParam() {
        java.lang.Object ref = vabcCompressionParam_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            vabcCompressionParam_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The compression algorithm used by VABC. Available ones are "gz", "brotli".
       * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
       * as this parameter is ultimated forwarded to libsnapshot's CowWriter
       * </pre>
       *
       * <code>optional string vabc_compression_param = 4;</code>
       * @return The bytes for vabcCompressionParam.
       */
      public com.google.protobuf.ByteString
          getVabcCompressionParamBytes() {
        java.lang.Object ref = vabcCompressionParam_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          vabcCompressionParam_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The compression algorithm used by VABC. Available ones are "gz", "brotli".
       * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
       * as this parameter is ultimated forwarded to libsnapshot's CowWriter
       * </pre>
       *
       * <code>optional string vabc_compression_param = 4;</code>
       * @param value The vabcCompressionParam to set.
       * @return This builder for chaining.
       */
      public Builder setVabcCompressionParam(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        vabcCompressionParam_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The compression algorithm used by VABC. Available ones are "gz", "brotli".
       * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
       * as this parameter is ultimated forwarded to libsnapshot's CowWriter
       * </pre>
       *
       * <code>optional string vabc_compression_param = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearVabcCompressionParam() {
        vabcCompressionParam_ = getDefaultInstance().getVabcCompressionParam();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The compression algorithm used by VABC. Available ones are "gz", "brotli".
       * See system/core/fs_mgr/libsnapshot/cow_writer.cpp for available options,
       * as this parameter is ultimated forwarded to libsnapshot's CowWriter
       * </pre>
       *
       * <code>optional string vabc_compression_param = 4;</code>
       * @param value The bytes for vabcCompressionParam to set.
       * @return This builder for chaining.
       */
      public Builder setVabcCompressionParamBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        vabcCompressionParam_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private int cowVersion_ ;
      /**
       * <pre>
       * COW version used by VABC. The represents the major version in the COW
       * header
       * </pre>
       *
       * <code>optional uint32 cow_version = 5;</code>
       * @return Whether the cowVersion field is set.
       */
      @java.lang.Override
      public boolean hasCowVersion() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * COW version used by VABC. The represents the major version in the COW
       * header
       * </pre>
       *
       * <code>optional uint32 cow_version = 5;</code>
       * @return The cowVersion.
       */
      @java.lang.Override
      public int getCowVersion() {
        return cowVersion_;
      }
      /**
       * <pre>
       * COW version used by VABC. The represents the major version in the COW
       * header
       * </pre>
       *
       * <code>optional uint32 cow_version = 5;</code>
       * @param value The cowVersion to set.
       * @return This builder for chaining.
       */
      public Builder setCowVersion(int value) {
        
        cowVersion_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * COW version used by VABC. The represents the major version in the COW
       * header
       * </pre>
       *
       * <code>optional uint32 cow_version = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearCowVersion() {
        bitField0_ = (bitField0_ & ~0x00000010);
        cowVersion_ = 0;
        onChanged();
        return this;
      }

      private chromeos_update_engine.UpdateMetadata.VABCFeatureSet vabcFeatureSet_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.VABCFeatureSet, chromeos_update_engine.UpdateMetadata.VABCFeatureSet.Builder, chromeos_update_engine.UpdateMetadata.VABCFeatureSetOrBuilder> vabcFeatureSetBuilder_;
      /**
       * <pre>
       * A collection of knobs to tune Virtual AB Compression
       * </pre>
       *
       * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
       * @return Whether the vabcFeatureSet field is set.
       */
      public boolean hasVabcFeatureSet() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * A collection of knobs to tune Virtual AB Compression
       * </pre>
       *
       * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
       * @return The vabcFeatureSet.
       */
      public chromeos_update_engine.UpdateMetadata.VABCFeatureSet getVabcFeatureSet() {
        if (vabcFeatureSetBuilder_ == null) {
          return vabcFeatureSet_ == null ? chromeos_update_engine.UpdateMetadata.VABCFeatureSet.getDefaultInstance() : vabcFeatureSet_;
        } else {
          return vabcFeatureSetBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * A collection of knobs to tune Virtual AB Compression
       * </pre>
       *
       * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
       */
      public Builder setVabcFeatureSet(chromeos_update_engine.UpdateMetadata.VABCFeatureSet value) {
        if (vabcFeatureSetBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          vabcFeatureSet_ = value;
        } else {
          vabcFeatureSetBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A collection of knobs to tune Virtual AB Compression
       * </pre>
       *
       * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
       */
      public Builder setVabcFeatureSet(
          chromeos_update_engine.UpdateMetadata.VABCFeatureSet.Builder builderForValue) {
        if (vabcFeatureSetBuilder_ == null) {
          vabcFeatureSet_ = builderForValue.build();
        } else {
          vabcFeatureSetBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A collection of knobs to tune Virtual AB Compression
       * </pre>
       *
       * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
       */
      public Builder mergeVabcFeatureSet(chromeos_update_engine.UpdateMetadata.VABCFeatureSet value) {
        if (vabcFeatureSetBuilder_ == null) {
          if (((bitField0_ & 0x00000020) != 0) &&
            vabcFeatureSet_ != null &&
            vabcFeatureSet_ != chromeos_update_engine.UpdateMetadata.VABCFeatureSet.getDefaultInstance()) {
            getVabcFeatureSetBuilder().mergeFrom(value);
          } else {
            vabcFeatureSet_ = value;
          }
        } else {
          vabcFeatureSetBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A collection of knobs to tune Virtual AB Compression
       * </pre>
       *
       * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
       */
      public Builder clearVabcFeatureSet() {
        bitField0_ = (bitField0_ & ~0x00000020);
        vabcFeatureSet_ = null;
        if (vabcFeatureSetBuilder_ != null) {
          vabcFeatureSetBuilder_.dispose();
          vabcFeatureSetBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A collection of knobs to tune Virtual AB Compression
       * </pre>
       *
       * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.VABCFeatureSet.Builder getVabcFeatureSetBuilder() {
        bitField0_ |= 0x00000020;
        onChanged();
        return getVabcFeatureSetFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * A collection of knobs to tune Virtual AB Compression
       * </pre>
       *
       * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
       */
      public chromeos_update_engine.UpdateMetadata.VABCFeatureSetOrBuilder getVabcFeatureSetOrBuilder() {
        if (vabcFeatureSetBuilder_ != null) {
          return vabcFeatureSetBuilder_.getMessageOrBuilder();
        } else {
          return vabcFeatureSet_ == null ?
              chromeos_update_engine.UpdateMetadata.VABCFeatureSet.getDefaultInstance() : vabcFeatureSet_;
        }
      }
      /**
       * <pre>
       * A collection of knobs to tune Virtual AB Compression
       * </pre>
       *
       * <code>optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.VABCFeatureSet, chromeos_update_engine.UpdateMetadata.VABCFeatureSet.Builder, chromeos_update_engine.UpdateMetadata.VABCFeatureSetOrBuilder> 
          getVabcFeatureSetFieldBuilder() {
        if (vabcFeatureSetBuilder_ == null) {
          vabcFeatureSetBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.VABCFeatureSet, chromeos_update_engine.UpdateMetadata.VABCFeatureSet.Builder, chromeos_update_engine.UpdateMetadata.VABCFeatureSetOrBuilder>(
                  getVabcFeatureSet(),
                  getParentForChildren(),
                  isClean());
          vabcFeatureSet_ = null;
        }
        return vabcFeatureSetBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.DynamicPartitionMetadata)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionMetadata)
    private static final chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata();
    }

    public static chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<DynamicPartitionMetadata>
        PARSER = new com.google.protobuf.AbstractParser<DynamicPartitionMetadata>() {
      @java.lang.Override
      public DynamicPartitionMetadata parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DynamicPartitionMetadata> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DynamicPartitionMetadata> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ApexInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.ApexInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>optional string package_name = 1;</code>
     * @return Whether the packageName field is set.
     */
    boolean hasPackageName();
    /**
     * <code>optional string package_name = 1;</code>
     * @return The packageName.
     */
    java.lang.String getPackageName();
    /**
     * <code>optional string package_name = 1;</code>
     * @return The bytes for packageName.
     */
    com.google.protobuf.ByteString
        getPackageNameBytes();

    /**
     * <code>optional int64 version = 2;</code>
     * @return Whether the version field is set.
     */
    boolean hasVersion();
    /**
     * <code>optional int64 version = 2;</code>
     * @return The version.
     */
    long getVersion();

    /**
     * <code>optional bool is_compressed = 3;</code>
     * @return Whether the isCompressed field is set.
     */
    boolean hasIsCompressed();
    /**
     * <code>optional bool is_compressed = 3;</code>
     * @return The isCompressed.
     */
    boolean getIsCompressed();

    /**
     * <code>optional int64 decompressed_size = 4;</code>
     * @return Whether the decompressedSize field is set.
     */
    boolean hasDecompressedSize();
    /**
     * <code>optional int64 decompressed_size = 4;</code>
     * @return The decompressedSize.
     */
    long getDecompressedSize();
  }
  /**
   * <pre>
   * Definition has been duplicated from
   * $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
   * </pre>
   *
   * Protobuf type {@code chromeos_update_engine.ApexInfo}
   */
  public static final class ApexInfo extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.ApexInfo)
      ApexInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ApexInfo.newBuilder() to construct.
    private ApexInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ApexInfo() {
      packageName_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ApexInfo();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ApexInfo_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ApexInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.ApexInfo.class, chromeos_update_engine.UpdateMetadata.ApexInfo.Builder.class);
    }

    private int bitField0_;
    public static final int PACKAGE_NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object packageName_ = "";
    /**
     * <code>optional string package_name = 1;</code>
     * @return Whether the packageName field is set.
     */
    @java.lang.Override
    public boolean hasPackageName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional string package_name = 1;</code>
     * @return The packageName.
     */
    @java.lang.Override
    public java.lang.String getPackageName() {
      java.lang.Object ref = packageName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          packageName_ = s;
        }
        return s;
      }
    }
    /**
     * <code>optional string package_name = 1;</code>
     * @return The bytes for packageName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getPackageNameBytes() {
      java.lang.Object ref = packageName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        packageName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VERSION_FIELD_NUMBER = 2;
    private long version_ = 0L;
    /**
     * <code>optional int64 version = 2;</code>
     * @return Whether the version field is set.
     */
    @java.lang.Override
    public boolean hasVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional int64 version = 2;</code>
     * @return The version.
     */
    @java.lang.Override
    public long getVersion() {
      return version_;
    }

    public static final int IS_COMPRESSED_FIELD_NUMBER = 3;
    private boolean isCompressed_ = false;
    /**
     * <code>optional bool is_compressed = 3;</code>
     * @return Whether the isCompressed field is set.
     */
    @java.lang.Override
    public boolean hasIsCompressed() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional bool is_compressed = 3;</code>
     * @return The isCompressed.
     */
    @java.lang.Override
    public boolean getIsCompressed() {
      return isCompressed_;
    }

    public static final int DECOMPRESSED_SIZE_FIELD_NUMBER = 4;
    private long decompressedSize_ = 0L;
    /**
     * <code>optional int64 decompressed_size = 4;</code>
     * @return Whether the decompressedSize field is set.
     */
    @java.lang.Override
    public boolean hasDecompressedSize() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional int64 decompressed_size = 4;</code>
     * @return The decompressedSize.
     */
    @java.lang.Override
    public long getDecompressedSize() {
      return decompressedSize_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, packageName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeInt64(2, version_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeBool(3, isCompressed_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeInt64(4, decompressedSize_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, packageName_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(2, version_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, isCompressed_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(4, decompressedSize_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.ApexInfo)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.ApexInfo other = (chromeos_update_engine.UpdateMetadata.ApexInfo) obj;

      if (hasPackageName() != other.hasPackageName()) return false;
      if (hasPackageName()) {
        if (!getPackageName()
            .equals(other.getPackageName())) return false;
      }
      if (hasVersion() != other.hasVersion()) return false;
      if (hasVersion()) {
        if (getVersion()
            != other.getVersion()) return false;
      }
      if (hasIsCompressed() != other.hasIsCompressed()) return false;
      if (hasIsCompressed()) {
        if (getIsCompressed()
            != other.getIsCompressed()) return false;
      }
      if (hasDecompressedSize() != other.hasDecompressedSize()) return false;
      if (hasDecompressedSize()) {
        if (getDecompressedSize()
            != other.getDecompressedSize()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPackageName()) {
        hash = (37 * hash) + PACKAGE_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getPackageName().hashCode();
      }
      if (hasVersion()) {
        hash = (37 * hash) + VERSION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getVersion());
      }
      if (hasIsCompressed()) {
        hash = (37 * hash) + IS_COMPRESSED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getIsCompressed());
      }
      if (hasDecompressedSize()) {
        hash = (37 * hash) + DECOMPRESSED_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDecompressedSize());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.ApexInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.ApexInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Definition has been duplicated from
     * $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
     * </pre>
     *
     * Protobuf type {@code chromeos_update_engine.ApexInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.ApexInfo)
        chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ApexInfo_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ApexInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.ApexInfo.class, chromeos_update_engine.UpdateMetadata.ApexInfo.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.ApexInfo.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        packageName_ = "";
        version_ = 0L;
        isCompressed_ = false;
        decompressedSize_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ApexInfo_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.ApexInfo getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.ApexInfo.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.ApexInfo build() {
        chromeos_update_engine.UpdateMetadata.ApexInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.ApexInfo buildPartial() {
        chromeos_update_engine.UpdateMetadata.ApexInfo result = new chromeos_update_engine.UpdateMetadata.ApexInfo(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(chromeos_update_engine.UpdateMetadata.ApexInfo result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.packageName_ = packageName_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.version_ = version_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.isCompressed_ = isCompressed_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.decompressedSize_ = decompressedSize_;
          to_bitField0_ |= 0x00000008;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.ApexInfo) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.ApexInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.ApexInfo other) {
        if (other == chromeos_update_engine.UpdateMetadata.ApexInfo.getDefaultInstance()) return this;
        if (other.hasPackageName()) {
          packageName_ = other.packageName_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasVersion()) {
          setVersion(other.getVersion());
        }
        if (other.hasIsCompressed()) {
          setIsCompressed(other.getIsCompressed());
        }
        if (other.hasDecompressedSize()) {
          setDecompressedSize(other.getDecompressedSize());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                packageName_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                version_ = input.readInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                isCompressed_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                decompressedSize_ = input.readInt64();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object packageName_ = "";
      /**
       * <code>optional string package_name = 1;</code>
       * @return Whether the packageName field is set.
       */
      public boolean hasPackageName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional string package_name = 1;</code>
       * @return The packageName.
       */
      public java.lang.String getPackageName() {
        java.lang.Object ref = packageName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            packageName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>optional string package_name = 1;</code>
       * @return The bytes for packageName.
       */
      public com.google.protobuf.ByteString
          getPackageNameBytes() {
        java.lang.Object ref = packageName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          packageName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string package_name = 1;</code>
       * @param value The packageName to set.
       * @return This builder for chaining.
       */
      public Builder setPackageName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        packageName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <code>optional string package_name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPackageName() {
        packageName_ = getDefaultInstance().getPackageName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <code>optional string package_name = 1;</code>
       * @param value The bytes for packageName to set.
       * @return This builder for chaining.
       */
      public Builder setPackageNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        packageName_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private long version_ ;
      /**
       * <code>optional int64 version = 2;</code>
       * @return Whether the version field is set.
       */
      @java.lang.Override
      public boolean hasVersion() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional int64 version = 2;</code>
       * @return The version.
       */
      @java.lang.Override
      public long getVersion() {
        return version_;
      }
      /**
       * <code>optional int64 version = 2;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(long value) {
        
        version_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <code>optional int64 version = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        bitField0_ = (bitField0_ & ~0x00000002);
        version_ = 0L;
        onChanged();
        return this;
      }

      private boolean isCompressed_ ;
      /**
       * <code>optional bool is_compressed = 3;</code>
       * @return Whether the isCompressed field is set.
       */
      @java.lang.Override
      public boolean hasIsCompressed() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional bool is_compressed = 3;</code>
       * @return The isCompressed.
       */
      @java.lang.Override
      public boolean getIsCompressed() {
        return isCompressed_;
      }
      /**
       * <code>optional bool is_compressed = 3;</code>
       * @param value The isCompressed to set.
       * @return This builder for chaining.
       */
      public Builder setIsCompressed(boolean value) {
        
        isCompressed_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool is_compressed = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearIsCompressed() {
        bitField0_ = (bitField0_ & ~0x00000004);
        isCompressed_ = false;
        onChanged();
        return this;
      }

      private long decompressedSize_ ;
      /**
       * <code>optional int64 decompressed_size = 4;</code>
       * @return Whether the decompressedSize field is set.
       */
      @java.lang.Override
      public boolean hasDecompressedSize() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional int64 decompressed_size = 4;</code>
       * @return The decompressedSize.
       */
      @java.lang.Override
      public long getDecompressedSize() {
        return decompressedSize_;
      }
      /**
       * <code>optional int64 decompressed_size = 4;</code>
       * @param value The decompressedSize to set.
       * @return This builder for chaining.
       */
      public Builder setDecompressedSize(long value) {
        
        decompressedSize_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <code>optional int64 decompressed_size = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearDecompressedSize() {
        bitField0_ = (bitField0_ & ~0x00000008);
        decompressedSize_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.ApexInfo)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.ApexInfo)
    private static final chromeos_update_engine.UpdateMetadata.ApexInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.ApexInfo();
    }

    public static chromeos_update_engine.UpdateMetadata.ApexInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ApexInfo>
        PARSER = new com.google.protobuf.AbstractParser<ApexInfo>() {
      @java.lang.Override
      public ApexInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ApexInfo> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ApexInfo> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ApexInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ApexMetadataOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.ApexMetadata)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.ApexInfo> 
        getApexInfoList();
    /**
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
     */
    chromeos_update_engine.UpdateMetadata.ApexInfo getApexInfo(int index);
    /**
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
     */
    int getApexInfoCount();
    /**
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder> 
        getApexInfoOrBuilderList();
    /**
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
     */
    chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder getApexInfoOrBuilder(
        int index);
  }
  /**
   * <pre>
   * Definition has been duplicated from
   * $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
   * </pre>
   *
   * Protobuf type {@code chromeos_update_engine.ApexMetadata}
   */
  public static final class ApexMetadata extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.ApexMetadata)
      ApexMetadataOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ApexMetadata.newBuilder() to construct.
    private ApexMetadata(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ApexMetadata() {
      apexInfo_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ApexMetadata();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ApexMetadata_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ApexMetadata_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.ApexMetadata.class, chromeos_update_engine.UpdateMetadata.ApexMetadata.Builder.class);
    }

    public static final int APEX_INFO_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<chromeos_update_engine.UpdateMetadata.ApexInfo> apexInfo_;
    /**
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.ApexInfo> getApexInfoList() {
      return apexInfo_;
    }
    /**
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder> 
        getApexInfoOrBuilderList() {
      return apexInfo_;
    }
    /**
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
     */
    @java.lang.Override
    public int getApexInfoCount() {
      return apexInfo_.size();
    }
    /**
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ApexInfo getApexInfo(int index) {
      return apexInfo_.get(index);
    }
    /**
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder getApexInfoOrBuilder(
        int index) {
      return apexInfo_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < apexInfo_.size(); i++) {
        output.writeMessage(1, apexInfo_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < apexInfo_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, apexInfo_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.ApexMetadata)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.ApexMetadata other = (chromeos_update_engine.UpdateMetadata.ApexMetadata) obj;

      if (!getApexInfoList()
          .equals(other.getApexInfoList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getApexInfoCount() > 0) {
        hash = (37 * hash) + APEX_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getApexInfoList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.ApexMetadata parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexMetadata parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexMetadata parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexMetadata parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexMetadata parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexMetadata parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexMetadata parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexMetadata parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexMetadata parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexMetadata parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexMetadata parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.ApexMetadata parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.ApexMetadata prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Definition has been duplicated from
     * $ANDROID_BUILD_TOP/build/tools/releasetools/ota_metadata.proto. Keep in sync.
     * </pre>
     *
     * Protobuf type {@code chromeos_update_engine.ApexMetadata}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.ApexMetadata)
        chromeos_update_engine.UpdateMetadata.ApexMetadataOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ApexMetadata_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ApexMetadata_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.ApexMetadata.class, chromeos_update_engine.UpdateMetadata.ApexMetadata.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.ApexMetadata.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (apexInfoBuilder_ == null) {
          apexInfo_ = java.util.Collections.emptyList();
        } else {
          apexInfo_ = null;
          apexInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_ApexMetadata_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.ApexMetadata getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.ApexMetadata.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.ApexMetadata build() {
        chromeos_update_engine.UpdateMetadata.ApexMetadata result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.ApexMetadata buildPartial() {
        chromeos_update_engine.UpdateMetadata.ApexMetadata result = new chromeos_update_engine.UpdateMetadata.ApexMetadata(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(chromeos_update_engine.UpdateMetadata.ApexMetadata result) {
        if (apexInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            apexInfo_ = java.util.Collections.unmodifiableList(apexInfo_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.apexInfo_ = apexInfo_;
        } else {
          result.apexInfo_ = apexInfoBuilder_.build();
        }
      }

      private void buildPartial0(chromeos_update_engine.UpdateMetadata.ApexMetadata result) {
        int from_bitField0_ = bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.ApexMetadata) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.ApexMetadata)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.ApexMetadata other) {
        if (other == chromeos_update_engine.UpdateMetadata.ApexMetadata.getDefaultInstance()) return this;
        if (apexInfoBuilder_ == null) {
          if (!other.apexInfo_.isEmpty()) {
            if (apexInfo_.isEmpty()) {
              apexInfo_ = other.apexInfo_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureApexInfoIsMutable();
              apexInfo_.addAll(other.apexInfo_);
            }
            onChanged();
          }
        } else {
          if (!other.apexInfo_.isEmpty()) {
            if (apexInfoBuilder_.isEmpty()) {
              apexInfoBuilder_.dispose();
              apexInfoBuilder_ = null;
              apexInfo_ = other.apexInfo_;
              bitField0_ = (bitField0_ & ~0x00000001);
              apexInfoBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getApexInfoFieldBuilder() : null;
            } else {
              apexInfoBuilder_.addAllMessages(other.apexInfo_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                chromeos_update_engine.UpdateMetadata.ApexInfo m =
                    input.readMessage(
                        chromeos_update_engine.UpdateMetadata.ApexInfo.PARSER,
                        extensionRegistry);
                if (apexInfoBuilder_ == null) {
                  ensureApexInfoIsMutable();
                  apexInfo_.add(m);
                } else {
                  apexInfoBuilder_.addMessage(m);
                }
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<chromeos_update_engine.UpdateMetadata.ApexInfo> apexInfo_ =
        java.util.Collections.emptyList();
      private void ensureApexInfoIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          apexInfo_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.ApexInfo>(apexInfo_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.ApexInfo, chromeos_update_engine.UpdateMetadata.ApexInfo.Builder, chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder> apexInfoBuilder_;

      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.ApexInfo> getApexInfoList() {
        if (apexInfoBuilder_ == null) {
          return java.util.Collections.unmodifiableList(apexInfo_);
        } else {
          return apexInfoBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public int getApexInfoCount() {
        if (apexInfoBuilder_ == null) {
          return apexInfo_.size();
        } else {
          return apexInfoBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ApexInfo getApexInfo(int index) {
        if (apexInfoBuilder_ == null) {
          return apexInfo_.get(index);
        } else {
          return apexInfoBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public Builder setApexInfo(
          int index, chromeos_update_engine.UpdateMetadata.ApexInfo value) {
        if (apexInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureApexInfoIsMutable();
          apexInfo_.set(index, value);
          onChanged();
        } else {
          apexInfoBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public Builder setApexInfo(
          int index, chromeos_update_engine.UpdateMetadata.ApexInfo.Builder builderForValue) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.set(index, builderForValue.build());
          onChanged();
        } else {
          apexInfoBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public Builder addApexInfo(chromeos_update_engine.UpdateMetadata.ApexInfo value) {
        if (apexInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureApexInfoIsMutable();
          apexInfo_.add(value);
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public Builder addApexInfo(
          int index, chromeos_update_engine.UpdateMetadata.ApexInfo value) {
        if (apexInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureApexInfoIsMutable();
          apexInfo_.add(index, value);
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public Builder addApexInfo(
          chromeos_update_engine.UpdateMetadata.ApexInfo.Builder builderForValue) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.add(builderForValue.build());
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public Builder addApexInfo(
          int index, chromeos_update_engine.UpdateMetadata.ApexInfo.Builder builderForValue) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.add(index, builderForValue.build());
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public Builder addAllApexInfo(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.ApexInfo> values) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, apexInfo_);
          onChanged();
        } else {
          apexInfoBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public Builder clearApexInfo() {
        if (apexInfoBuilder_ == null) {
          apexInfo_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          apexInfoBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public Builder removeApexInfo(int index) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.remove(index);
          onChanged();
        } else {
          apexInfoBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ApexInfo.Builder getApexInfoBuilder(
          int index) {
        return getApexInfoFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder getApexInfoOrBuilder(
          int index) {
        if (apexInfoBuilder_ == null) {
          return apexInfo_.get(index);  } else {
          return apexInfoBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder> 
           getApexInfoOrBuilderList() {
        if (apexInfoBuilder_ != null) {
          return apexInfoBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(apexInfo_);
        }
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ApexInfo.Builder addApexInfoBuilder() {
        return getApexInfoFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.ApexInfo.getDefaultInstance());
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ApexInfo.Builder addApexInfoBuilder(
          int index) {
        return getApexInfoFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.ApexInfo.getDefaultInstance());
      }
      /**
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 1;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.ApexInfo.Builder> 
           getApexInfoBuilderList() {
        return getApexInfoFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.ApexInfo, chromeos_update_engine.UpdateMetadata.ApexInfo.Builder, chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder> 
          getApexInfoFieldBuilder() {
        if (apexInfoBuilder_ == null) {
          apexInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.ApexInfo, chromeos_update_engine.UpdateMetadata.ApexInfo.Builder, chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder>(
                  apexInfo_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          apexInfo_ = null;
        }
        return apexInfoBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.ApexMetadata)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.ApexMetadata)
    private static final chromeos_update_engine.UpdateMetadata.ApexMetadata DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.ApexMetadata();
    }

    public static chromeos_update_engine.UpdateMetadata.ApexMetadata getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<ApexMetadata>
        PARSER = new com.google.protobuf.AbstractParser<ApexMetadata>() {
      @java.lang.Override
      public ApexMetadata parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ApexMetadata> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ApexMetadata> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ApexMetadata getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DeltaArchiveManifestOrBuilder extends
      // @@protoc_insertion_point(interface_extends:chromeos_update_engine.DeltaArchiveManifest)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * (At time of writing) usually 4096
     * </pre>
     *
     * <code>optional uint32 block_size = 3 [default = 4096];</code>
     * @return Whether the blockSize field is set.
     */
    boolean hasBlockSize();
    /**
     * <pre>
     * (At time of writing) usually 4096
     * </pre>
     *
     * <code>optional uint32 block_size = 3 [default = 4096];</code>
     * @return The blockSize.
     */
    int getBlockSize();

    /**
     * <pre>
     * If signatures are present, the offset into the blobs, generally
     * tacked onto the end of the file, and the length. We use an offset
     * rather than a bool to allow for more flexibility in future file formats.
     * If either is absent, it means signatures aren't supported in this
     * file.
     * </pre>
     *
     * <code>optional uint64 signatures_offset = 4;</code>
     * @return Whether the signaturesOffset field is set.
     */
    boolean hasSignaturesOffset();
    /**
     * <pre>
     * If signatures are present, the offset into the blobs, generally
     * tacked onto the end of the file, and the length. We use an offset
     * rather than a bool to allow for more flexibility in future file formats.
     * If either is absent, it means signatures aren't supported in this
     * file.
     * </pre>
     *
     * <code>optional uint64 signatures_offset = 4;</code>
     * @return The signaturesOffset.
     */
    long getSignaturesOffset();

    /**
     * <code>optional uint64 signatures_size = 5;</code>
     * @return Whether the signaturesSize field is set.
     */
    boolean hasSignaturesSize();
    /**
     * <code>optional uint64 signatures_size = 5;</code>
     * @return The signaturesSize.
     */
    long getSignaturesSize();

    /**
     * <pre>
     * The minor version, also referred as "delta version", of the payload.
     * Minor version 0 is full payload, everything else is delta payload.
     * </pre>
     *
     * <code>optional uint32 minor_version = 12 [default = 0];</code>
     * @return Whether the minorVersion field is set.
     */
    boolean hasMinorVersion();
    /**
     * <pre>
     * The minor version, also referred as "delta version", of the payload.
     * Minor version 0 is full payload, everything else is delta payload.
     * </pre>
     *
     * <code>optional uint32 minor_version = 12 [default = 0];</code>
     * @return The minorVersion.
     */
    int getMinorVersion();

    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.PartitionUpdate> 
        getPartitionsList();
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    chromeos_update_engine.UpdateMetadata.PartitionUpdate getPartitions(int index);
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    int getPartitionsCount();
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder> 
        getPartitionsOrBuilderList();
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder getPartitionsOrBuilder(
        int index);

    /**
     * <pre>
     * The maximum timestamp of the OS allowed to apply this payload.
     * Can be used to prevent downgrading the OS.
     * </pre>
     *
     * <code>optional int64 max_timestamp = 14;</code>
     * @return Whether the maxTimestamp field is set.
     */
    boolean hasMaxTimestamp();
    /**
     * <pre>
     * The maximum timestamp of the OS allowed to apply this payload.
     * Can be used to prevent downgrading the OS.
     * </pre>
     *
     * <code>optional int64 max_timestamp = 14;</code>
     * @return The maxTimestamp.
     */
    long getMaxTimestamp();

    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     * @return Whether the dynamicPartitionMetadata field is set.
     */
    boolean hasDynamicPartitionMetadata();
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     * @return The dynamicPartitionMetadata.
     */
    chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata getDynamicPartitionMetadata();
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     */
    chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadataOrBuilder getDynamicPartitionMetadataOrBuilder();

    /**
     * <pre>
     * If the payload only updates a subset of partitions on the device.
     * </pre>
     *
     * <code>optional bool partial_update = 16;</code>
     * @return Whether the partialUpdate field is set.
     */
    boolean hasPartialUpdate();
    /**
     * <pre>
     * If the payload only updates a subset of partitions on the device.
     * </pre>
     *
     * <code>optional bool partial_update = 16;</code>
     * @return The partialUpdate.
     */
    boolean getPartialUpdate();

    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
     */
    java.util.List<chromeos_update_engine.UpdateMetadata.ApexInfo> 
        getApexInfoList();
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
     */
    chromeos_update_engine.UpdateMetadata.ApexInfo getApexInfo(int index);
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
     */
    int getApexInfoCount();
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
     */
    java.util.List<? extends chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder> 
        getApexInfoOrBuilderList();
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
     */
    chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder getApexInfoOrBuilder(
        int index);

    /**
     * <pre>
     * Security patch level of the device, usually in the format of
     * yyyy-mm-dd
     * </pre>
     *
     * <code>optional string security_patch_level = 18;</code>
     * @return Whether the securityPatchLevel field is set.
     */
    boolean hasSecurityPatchLevel();
    /**
     * <pre>
     * Security patch level of the device, usually in the format of
     * yyyy-mm-dd
     * </pre>
     *
     * <code>optional string security_patch_level = 18;</code>
     * @return The securityPatchLevel.
     */
    java.lang.String getSecurityPatchLevel();
    /**
     * <pre>
     * Security patch level of the device, usually in the format of
     * yyyy-mm-dd
     * </pre>
     *
     * <code>optional string security_patch_level = 18;</code>
     * @return The bytes for securityPatchLevel.
     */
    com.google.protobuf.ByteString
        getSecurityPatchLevelBytes();
  }
  /**
   * Protobuf type {@code chromeos_update_engine.DeltaArchiveManifest}
   */
  public static final class DeltaArchiveManifest extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:chromeos_update_engine.DeltaArchiveManifest)
      DeltaArchiveManifestOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DeltaArchiveManifest.newBuilder() to construct.
    private DeltaArchiveManifest(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DeltaArchiveManifest() {
      blockSize_ = 4096;
      partitions_ = java.util.Collections.emptyList();
      apexInfo_ = java.util.Collections.emptyList();
      securityPatchLevel_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new DeltaArchiveManifest();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest.class, chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest.Builder.class);
    }

    private int bitField0_;
    public static final int BLOCK_SIZE_FIELD_NUMBER = 3;
    private int blockSize_ = 4096;
    /**
     * <pre>
     * (At time of writing) usually 4096
     * </pre>
     *
     * <code>optional uint32 block_size = 3 [default = 4096];</code>
     * @return Whether the blockSize field is set.
     */
    @java.lang.Override
    public boolean hasBlockSize() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * (At time of writing) usually 4096
     * </pre>
     *
     * <code>optional uint32 block_size = 3 [default = 4096];</code>
     * @return The blockSize.
     */
    @java.lang.Override
    public int getBlockSize() {
      return blockSize_;
    }

    public static final int SIGNATURES_OFFSET_FIELD_NUMBER = 4;
    private long signaturesOffset_ = 0L;
    /**
     * <pre>
     * If signatures are present, the offset into the blobs, generally
     * tacked onto the end of the file, and the length. We use an offset
     * rather than a bool to allow for more flexibility in future file formats.
     * If either is absent, it means signatures aren't supported in this
     * file.
     * </pre>
     *
     * <code>optional uint64 signatures_offset = 4;</code>
     * @return Whether the signaturesOffset field is set.
     */
    @java.lang.Override
    public boolean hasSignaturesOffset() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * If signatures are present, the offset into the blobs, generally
     * tacked onto the end of the file, and the length. We use an offset
     * rather than a bool to allow for more flexibility in future file formats.
     * If either is absent, it means signatures aren't supported in this
     * file.
     * </pre>
     *
     * <code>optional uint64 signatures_offset = 4;</code>
     * @return The signaturesOffset.
     */
    @java.lang.Override
    public long getSignaturesOffset() {
      return signaturesOffset_;
    }

    public static final int SIGNATURES_SIZE_FIELD_NUMBER = 5;
    private long signaturesSize_ = 0L;
    /**
     * <code>optional uint64 signatures_size = 5;</code>
     * @return Whether the signaturesSize field is set.
     */
    @java.lang.Override
    public boolean hasSignaturesSize() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional uint64 signatures_size = 5;</code>
     * @return The signaturesSize.
     */
    @java.lang.Override
    public long getSignaturesSize() {
      return signaturesSize_;
    }

    public static final int MINOR_VERSION_FIELD_NUMBER = 12;
    private int minorVersion_ = 0;
    /**
     * <pre>
     * The minor version, also referred as "delta version", of the payload.
     * Minor version 0 is full payload, everything else is delta payload.
     * </pre>
     *
     * <code>optional uint32 minor_version = 12 [default = 0];</code>
     * @return Whether the minorVersion field is set.
     */
    @java.lang.Override
    public boolean hasMinorVersion() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The minor version, also referred as "delta version", of the payload.
     * Minor version 0 is full payload, everything else is delta payload.
     * </pre>
     *
     * <code>optional uint32 minor_version = 12 [default = 0];</code>
     * @return The minorVersion.
     */
    @java.lang.Override
    public int getMinorVersion() {
      return minorVersion_;
    }

    public static final int PARTITIONS_FIELD_NUMBER = 13;
    @SuppressWarnings("serial")
    private java.util.List<chromeos_update_engine.UpdateMetadata.PartitionUpdate> partitions_;
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.PartitionUpdate> getPartitionsList() {
      return partitions_;
    }
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder> 
        getPartitionsOrBuilderList() {
      return partitions_;
    }
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    @java.lang.Override
    public int getPartitionsCount() {
      return partitions_.size();
    }
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionUpdate getPartitions(int index) {
      return partitions_.get(index);
    }
    /**
     * <pre>
     * Only present in major version &gt;= 2. List of partitions that will be
     * updated, in the order they will be updated. This field replaces the
     * |install_operations|, |kernel_install_operations| and the
     * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
     * array can have more than two partitions if needed, and they are identified
     * by the partition name.
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder getPartitionsOrBuilder(
        int index) {
      return partitions_.get(index);
    }

    public static final int MAX_TIMESTAMP_FIELD_NUMBER = 14;
    private long maxTimestamp_ = 0L;
    /**
     * <pre>
     * The maximum timestamp of the OS allowed to apply this payload.
     * Can be used to prevent downgrading the OS.
     * </pre>
     *
     * <code>optional int64 max_timestamp = 14;</code>
     * @return Whether the maxTimestamp field is set.
     */
    @java.lang.Override
    public boolean hasMaxTimestamp() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * The maximum timestamp of the OS allowed to apply this payload.
     * Can be used to prevent downgrading the OS.
     * </pre>
     *
     * <code>optional int64 max_timestamp = 14;</code>
     * @return The maxTimestamp.
     */
    @java.lang.Override
    public long getMaxTimestamp() {
      return maxTimestamp_;
    }

    public static final int DYNAMIC_PARTITION_METADATA_FIELD_NUMBER = 15;
    private chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata dynamicPartitionMetadata_;
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     * @return Whether the dynamicPartitionMetadata field is set.
     */
    @java.lang.Override
    public boolean hasDynamicPartitionMetadata() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     * @return The dynamicPartitionMetadata.
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata getDynamicPartitionMetadata() {
      return dynamicPartitionMetadata_ == null ? chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.getDefaultInstance() : dynamicPartitionMetadata_;
    }
    /**
     * <pre>
     * Metadata related to all dynamic partitions.
     * </pre>
     *
     * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadataOrBuilder getDynamicPartitionMetadataOrBuilder() {
      return dynamicPartitionMetadata_ == null ? chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.getDefaultInstance() : dynamicPartitionMetadata_;
    }

    public static final int PARTIAL_UPDATE_FIELD_NUMBER = 16;
    private boolean partialUpdate_ = false;
    /**
     * <pre>
     * If the payload only updates a subset of partitions on the device.
     * </pre>
     *
     * <code>optional bool partial_update = 16;</code>
     * @return Whether the partialUpdate field is set.
     */
    @java.lang.Override
    public boolean hasPartialUpdate() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * If the payload only updates a subset of partitions on the device.
     * </pre>
     *
     * <code>optional bool partial_update = 16;</code>
     * @return The partialUpdate.
     */
    @java.lang.Override
    public boolean getPartialUpdate() {
      return partialUpdate_;
    }

    public static final int APEX_INFO_FIELD_NUMBER = 17;
    @SuppressWarnings("serial")
    private java.util.List<chromeos_update_engine.UpdateMetadata.ApexInfo> apexInfo_;
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
     */
    @java.lang.Override
    public java.util.List<chromeos_update_engine.UpdateMetadata.ApexInfo> getApexInfoList() {
      return apexInfo_;
    }
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
     */
    @java.lang.Override
    public java.util.List<? extends chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder> 
        getApexInfoOrBuilderList() {
      return apexInfo_;
    }
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
     */
    @java.lang.Override
    public int getApexInfoCount() {
      return apexInfo_.size();
    }
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ApexInfo getApexInfo(int index) {
      return apexInfo_.get(index);
    }
    /**
     * <pre>
     * Information on compressed APEX to figure out how much space is required for
     * their decompression
     * </pre>
     *
     * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
     */
    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder getApexInfoOrBuilder(
        int index) {
      return apexInfo_.get(index);
    }

    public static final int SECURITY_PATCH_LEVEL_FIELD_NUMBER = 18;
    @SuppressWarnings("serial")
    private volatile java.lang.Object securityPatchLevel_ = "";
    /**
     * <pre>
     * Security patch level of the device, usually in the format of
     * yyyy-mm-dd
     * </pre>
     *
     * <code>optional string security_patch_level = 18;</code>
     * @return Whether the securityPatchLevel field is set.
     */
    @java.lang.Override
    public boolean hasSecurityPatchLevel() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Security patch level of the device, usually in the format of
     * yyyy-mm-dd
     * </pre>
     *
     * <code>optional string security_patch_level = 18;</code>
     * @return The securityPatchLevel.
     */
    @java.lang.Override
    public java.lang.String getSecurityPatchLevel() {
      java.lang.Object ref = securityPatchLevel_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          securityPatchLevel_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Security patch level of the device, usually in the format of
     * yyyy-mm-dd
     * </pre>
     *
     * <code>optional string security_patch_level = 18;</code>
     * @return The bytes for securityPatchLevel.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getSecurityPatchLevelBytes() {
      java.lang.Object ref = securityPatchLevel_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        securityPatchLevel_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      for (int i = 0; i < getPartitionsCount(); i++) {
        if (!getPartitions(i).isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      if (hasDynamicPartitionMetadata()) {
        if (!getDynamicPartitionMetadata().isInitialized()) {
          memoizedIsInitialized = 0;
          return false;
        }
      }
      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt32(3, blockSize_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(4, signaturesOffset_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt64(5, signaturesSize_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt32(12, minorVersion_);
      }
      for (int i = 0; i < partitions_.size(); i++) {
        output.writeMessage(13, partitions_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeInt64(14, maxTimestamp_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeMessage(15, getDynamicPartitionMetadata());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBool(16, partialUpdate_);
      }
      for (int i = 0; i < apexInfo_.size(); i++) {
        output.writeMessage(17, apexInfo_.get(i));
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 18, securityPatchLevel_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, blockSize_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(4, signaturesOffset_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(5, signaturesSize_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(12, minorVersion_);
      }
      for (int i = 0; i < partitions_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(13, partitions_.get(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(14, maxTimestamp_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, getDynamicPartitionMetadata());
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(16, partialUpdate_);
      }
      for (int i = 0; i < apexInfo_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(17, apexInfo_.get(i));
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(18, securityPatchLevel_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest)) {
        return super.equals(obj);
      }
      chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest other = (chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest) obj;

      if (hasBlockSize() != other.hasBlockSize()) return false;
      if (hasBlockSize()) {
        if (getBlockSize()
            != other.getBlockSize()) return false;
      }
      if (hasSignaturesOffset() != other.hasSignaturesOffset()) return false;
      if (hasSignaturesOffset()) {
        if (getSignaturesOffset()
            != other.getSignaturesOffset()) return false;
      }
      if (hasSignaturesSize() != other.hasSignaturesSize()) return false;
      if (hasSignaturesSize()) {
        if (getSignaturesSize()
            != other.getSignaturesSize()) return false;
      }
      if (hasMinorVersion() != other.hasMinorVersion()) return false;
      if (hasMinorVersion()) {
        if (getMinorVersion()
            != other.getMinorVersion()) return false;
      }
      if (!getPartitionsList()
          .equals(other.getPartitionsList())) return false;
      if (hasMaxTimestamp() != other.hasMaxTimestamp()) return false;
      if (hasMaxTimestamp()) {
        if (getMaxTimestamp()
            != other.getMaxTimestamp()) return false;
      }
      if (hasDynamicPartitionMetadata() != other.hasDynamicPartitionMetadata()) return false;
      if (hasDynamicPartitionMetadata()) {
        if (!getDynamicPartitionMetadata()
            .equals(other.getDynamicPartitionMetadata())) return false;
      }
      if (hasPartialUpdate() != other.hasPartialUpdate()) return false;
      if (hasPartialUpdate()) {
        if (getPartialUpdate()
            != other.getPartialUpdate()) return false;
      }
      if (!getApexInfoList()
          .equals(other.getApexInfoList())) return false;
      if (hasSecurityPatchLevel() != other.hasSecurityPatchLevel()) return false;
      if (hasSecurityPatchLevel()) {
        if (!getSecurityPatchLevel()
            .equals(other.getSecurityPatchLevel())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasBlockSize()) {
        hash = (37 * hash) + BLOCK_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + getBlockSize();
      }
      if (hasSignaturesOffset()) {
        hash = (37 * hash) + SIGNATURES_OFFSET_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSignaturesOffset());
      }
      if (hasSignaturesSize()) {
        hash = (37 * hash) + SIGNATURES_SIZE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getSignaturesSize());
      }
      if (hasMinorVersion()) {
        hash = (37 * hash) + MINOR_VERSION_FIELD_NUMBER;
        hash = (53 * hash) + getMinorVersion();
      }
      if (getPartitionsCount() > 0) {
        hash = (37 * hash) + PARTITIONS_FIELD_NUMBER;
        hash = (53 * hash) + getPartitionsList().hashCode();
      }
      if (hasMaxTimestamp()) {
        hash = (37 * hash) + MAX_TIMESTAMP_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getMaxTimestamp());
      }
      if (hasDynamicPartitionMetadata()) {
        hash = (37 * hash) + DYNAMIC_PARTITION_METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getDynamicPartitionMetadata().hashCode();
      }
      if (hasPartialUpdate()) {
        hash = (37 * hash) + PARTIAL_UPDATE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPartialUpdate());
      }
      if (getApexInfoCount() > 0) {
        hash = (37 * hash) + APEX_INFO_FIELD_NUMBER;
        hash = (53 * hash) + getApexInfoList().hashCode();
      }
      if (hasSecurityPatchLevel()) {
        hash = (37 * hash) + SECURITY_PATCH_LEVEL_FIELD_NUMBER;
        hash = (53 * hash) + getSecurityPatchLevel().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code chromeos_update_engine.DeltaArchiveManifest}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:chromeos_update_engine.DeltaArchiveManifest)
        chromeos_update_engine.UpdateMetadata.DeltaArchiveManifestOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest.class, chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest.Builder.class);
      }

      // Construct using chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getPartitionsFieldBuilder();
          getDynamicPartitionMetadataFieldBuilder();
          getApexInfoFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        blockSize_ = 4096;
        signaturesOffset_ = 0L;
        signaturesSize_ = 0L;
        minorVersion_ = 0;
        if (partitionsBuilder_ == null) {
          partitions_ = java.util.Collections.emptyList();
        } else {
          partitions_ = null;
          partitionsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000010);
        maxTimestamp_ = 0L;
        dynamicPartitionMetadata_ = null;
        if (dynamicPartitionMetadataBuilder_ != null) {
          dynamicPartitionMetadataBuilder_.dispose();
          dynamicPartitionMetadataBuilder_ = null;
        }
        partialUpdate_ = false;
        if (apexInfoBuilder_ == null) {
          apexInfo_ = java.util.Collections.emptyList();
        } else {
          apexInfo_ = null;
          apexInfoBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000100);
        securityPatchLevel_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return chromeos_update_engine.UpdateMetadata.internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest getDefaultInstanceForType() {
        return chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest.getDefaultInstance();
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest build() {
        chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest buildPartial() {
        chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest result = new chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest result) {
        if (partitionsBuilder_ == null) {
          if (((bitField0_ & 0x00000010) != 0)) {
            partitions_ = java.util.Collections.unmodifiableList(partitions_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.partitions_ = partitions_;
        } else {
          result.partitions_ = partitionsBuilder_.build();
        }
        if (apexInfoBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0)) {
            apexInfo_ = java.util.Collections.unmodifiableList(apexInfo_);
            bitField0_ = (bitField0_ & ~0x00000100);
          }
          result.apexInfo_ = apexInfo_;
        } else {
          result.apexInfo_ = apexInfoBuilder_.build();
        }
      }

      private void buildPartial0(chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.blockSize_ = blockSize_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.signaturesOffset_ = signaturesOffset_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.signaturesSize_ = signaturesSize_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.minorVersion_ = minorVersion_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.maxTimestamp_ = maxTimestamp_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.dynamicPartitionMetadata_ = dynamicPartitionMetadataBuilder_ == null
              ? dynamicPartitionMetadata_
              : dynamicPartitionMetadataBuilder_.build();
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.partialUpdate_ = partialUpdate_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.securityPatchLevel_ = securityPatchLevel_;
          to_bitField0_ |= 0x00000080;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest) {
          return mergeFrom((chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest other) {
        if (other == chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest.getDefaultInstance()) return this;
        if (other.hasBlockSize()) {
          setBlockSize(other.getBlockSize());
        }
        if (other.hasSignaturesOffset()) {
          setSignaturesOffset(other.getSignaturesOffset());
        }
        if (other.hasSignaturesSize()) {
          setSignaturesSize(other.getSignaturesSize());
        }
        if (other.hasMinorVersion()) {
          setMinorVersion(other.getMinorVersion());
        }
        if (partitionsBuilder_ == null) {
          if (!other.partitions_.isEmpty()) {
            if (partitions_.isEmpty()) {
              partitions_ = other.partitions_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensurePartitionsIsMutable();
              partitions_.addAll(other.partitions_);
            }
            onChanged();
          }
        } else {
          if (!other.partitions_.isEmpty()) {
            if (partitionsBuilder_.isEmpty()) {
              partitionsBuilder_.dispose();
              partitionsBuilder_ = null;
              partitions_ = other.partitions_;
              bitField0_ = (bitField0_ & ~0x00000010);
              partitionsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getPartitionsFieldBuilder() : null;
            } else {
              partitionsBuilder_.addAllMessages(other.partitions_);
            }
          }
        }
        if (other.hasMaxTimestamp()) {
          setMaxTimestamp(other.getMaxTimestamp());
        }
        if (other.hasDynamicPartitionMetadata()) {
          mergeDynamicPartitionMetadata(other.getDynamicPartitionMetadata());
        }
        if (other.hasPartialUpdate()) {
          setPartialUpdate(other.getPartialUpdate());
        }
        if (apexInfoBuilder_ == null) {
          if (!other.apexInfo_.isEmpty()) {
            if (apexInfo_.isEmpty()) {
              apexInfo_ = other.apexInfo_;
              bitField0_ = (bitField0_ & ~0x00000100);
            } else {
              ensureApexInfoIsMutable();
              apexInfo_.addAll(other.apexInfo_);
            }
            onChanged();
          }
        } else {
          if (!other.apexInfo_.isEmpty()) {
            if (apexInfoBuilder_.isEmpty()) {
              apexInfoBuilder_.dispose();
              apexInfoBuilder_ = null;
              apexInfo_ = other.apexInfo_;
              bitField0_ = (bitField0_ & ~0x00000100);
              apexInfoBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getApexInfoFieldBuilder() : null;
            } else {
              apexInfoBuilder_.addAllMessages(other.apexInfo_);
            }
          }
        }
        if (other.hasSecurityPatchLevel()) {
          securityPatchLevel_ = other.securityPatchLevel_;
          bitField0_ |= 0x00000200;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        for (int i = 0; i < getPartitionsCount(); i++) {
          if (!getPartitions(i).isInitialized()) {
            return false;
          }
        }
        if (hasDynamicPartitionMetadata()) {
          if (!getDynamicPartitionMetadata().isInitialized()) {
            return false;
          }
        }
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 24: {
                blockSize_ = input.readUInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 24
              case 32: {
                signaturesOffset_ = input.readUInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 32
              case 40: {
                signaturesSize_ = input.readUInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 40
              case 96: {
                minorVersion_ = input.readUInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 96
              case 106: {
                chromeos_update_engine.UpdateMetadata.PartitionUpdate m =
                    input.readMessage(
                        chromeos_update_engine.UpdateMetadata.PartitionUpdate.PARSER,
                        extensionRegistry);
                if (partitionsBuilder_ == null) {
                  ensurePartitionsIsMutable();
                  partitions_.add(m);
                } else {
                  partitionsBuilder_.addMessage(m);
                }
                break;
              } // case 106
              case 112: {
                maxTimestamp_ = input.readInt64();
                bitField0_ |= 0x00000020;
                break;
              } // case 112
              case 122: {
                input.readMessage(
                    getDynamicPartitionMetadataFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000040;
                break;
              } // case 122
              case 128: {
                partialUpdate_ = input.readBool();
                bitField0_ |= 0x00000080;
                break;
              } // case 128
              case 138: {
                chromeos_update_engine.UpdateMetadata.ApexInfo m =
                    input.readMessage(
                        chromeos_update_engine.UpdateMetadata.ApexInfo.PARSER,
                        extensionRegistry);
                if (apexInfoBuilder_ == null) {
                  ensureApexInfoIsMutable();
                  apexInfo_.add(m);
                } else {
                  apexInfoBuilder_.addMessage(m);
                }
                break;
              } // case 138
              case 146: {
                securityPatchLevel_ = input.readBytes();
                bitField0_ |= 0x00000200;
                break;
              } // case 146
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int blockSize_ = 4096;
      /**
       * <pre>
       * (At time of writing) usually 4096
       * </pre>
       *
       * <code>optional uint32 block_size = 3 [default = 4096];</code>
       * @return Whether the blockSize field is set.
       */
      @java.lang.Override
      public boolean hasBlockSize() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * (At time of writing) usually 4096
       * </pre>
       *
       * <code>optional uint32 block_size = 3 [default = 4096];</code>
       * @return The blockSize.
       */
      @java.lang.Override
      public int getBlockSize() {
        return blockSize_;
      }
      /**
       * <pre>
       * (At time of writing) usually 4096
       * </pre>
       *
       * <code>optional uint32 block_size = 3 [default = 4096];</code>
       * @param value The blockSize to set.
       * @return This builder for chaining.
       */
      public Builder setBlockSize(int value) {
        
        blockSize_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (At time of writing) usually 4096
       * </pre>
       *
       * <code>optional uint32 block_size = 3 [default = 4096];</code>
       * @return This builder for chaining.
       */
      public Builder clearBlockSize() {
        bitField0_ = (bitField0_ & ~0x00000001);
        blockSize_ = 4096;
        onChanged();
        return this;
      }

      private long signaturesOffset_ ;
      /**
       * <pre>
       * If signatures are present, the offset into the blobs, generally
       * tacked onto the end of the file, and the length. We use an offset
       * rather than a bool to allow for more flexibility in future file formats.
       * If either is absent, it means signatures aren't supported in this
       * file.
       * </pre>
       *
       * <code>optional uint64 signatures_offset = 4;</code>
       * @return Whether the signaturesOffset field is set.
       */
      @java.lang.Override
      public boolean hasSignaturesOffset() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * If signatures are present, the offset into the blobs, generally
       * tacked onto the end of the file, and the length. We use an offset
       * rather than a bool to allow for more flexibility in future file formats.
       * If either is absent, it means signatures aren't supported in this
       * file.
       * </pre>
       *
       * <code>optional uint64 signatures_offset = 4;</code>
       * @return The signaturesOffset.
       */
      @java.lang.Override
      public long getSignaturesOffset() {
        return signaturesOffset_;
      }
      /**
       * <pre>
       * If signatures are present, the offset into the blobs, generally
       * tacked onto the end of the file, and the length. We use an offset
       * rather than a bool to allow for more flexibility in future file formats.
       * If either is absent, it means signatures aren't supported in this
       * file.
       * </pre>
       *
       * <code>optional uint64 signatures_offset = 4;</code>
       * @param value The signaturesOffset to set.
       * @return This builder for chaining.
       */
      public Builder setSignaturesOffset(long value) {
        
        signaturesOffset_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If signatures are present, the offset into the blobs, generally
       * tacked onto the end of the file, and the length. We use an offset
       * rather than a bool to allow for more flexibility in future file formats.
       * If either is absent, it means signatures aren't supported in this
       * file.
       * </pre>
       *
       * <code>optional uint64 signatures_offset = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignaturesOffset() {
        bitField0_ = (bitField0_ & ~0x00000002);
        signaturesOffset_ = 0L;
        onChanged();
        return this;
      }

      private long signaturesSize_ ;
      /**
       * <code>optional uint64 signatures_size = 5;</code>
       * @return Whether the signaturesSize field is set.
       */
      @java.lang.Override
      public boolean hasSignaturesSize() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional uint64 signatures_size = 5;</code>
       * @return The signaturesSize.
       */
      @java.lang.Override
      public long getSignaturesSize() {
        return signaturesSize_;
      }
      /**
       * <code>optional uint64 signatures_size = 5;</code>
       * @param value The signaturesSize to set.
       * @return This builder for chaining.
       */
      public Builder setSignaturesSize(long value) {
        
        signaturesSize_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint64 signatures_size = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignaturesSize() {
        bitField0_ = (bitField0_ & ~0x00000004);
        signaturesSize_ = 0L;
        onChanged();
        return this;
      }

      private int minorVersion_ ;
      /**
       * <pre>
       * The minor version, also referred as "delta version", of the payload.
       * Minor version 0 is full payload, everything else is delta payload.
       * </pre>
       *
       * <code>optional uint32 minor_version = 12 [default = 0];</code>
       * @return Whether the minorVersion field is set.
       */
      @java.lang.Override
      public boolean hasMinorVersion() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The minor version, also referred as "delta version", of the payload.
       * Minor version 0 is full payload, everything else is delta payload.
       * </pre>
       *
       * <code>optional uint32 minor_version = 12 [default = 0];</code>
       * @return The minorVersion.
       */
      @java.lang.Override
      public int getMinorVersion() {
        return minorVersion_;
      }
      /**
       * <pre>
       * The minor version, also referred as "delta version", of the payload.
       * Minor version 0 is full payload, everything else is delta payload.
       * </pre>
       *
       * <code>optional uint32 minor_version = 12 [default = 0];</code>
       * @param value The minorVersion to set.
       * @return This builder for chaining.
       */
      public Builder setMinorVersion(int value) {
        
        minorVersion_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The minor version, also referred as "delta version", of the payload.
       * Minor version 0 is full payload, everything else is delta payload.
       * </pre>
       *
       * <code>optional uint32 minor_version = 12 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearMinorVersion() {
        bitField0_ = (bitField0_ & ~0x00000008);
        minorVersion_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<chromeos_update_engine.UpdateMetadata.PartitionUpdate> partitions_ =
        java.util.Collections.emptyList();
      private void ensurePartitionsIsMutable() {
        if (!((bitField0_ & 0x00000010) != 0)) {
          partitions_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.PartitionUpdate>(partitions_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionUpdate, chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder, chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder> partitionsBuilder_;

      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.PartitionUpdate> getPartitionsList() {
        if (partitionsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(partitions_);
        } else {
          return partitionsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public int getPartitionsCount() {
        if (partitionsBuilder_ == null) {
          return partitions_.size();
        } else {
          return partitionsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionUpdate getPartitions(int index) {
        if (partitionsBuilder_ == null) {
          return partitions_.get(index);
        } else {
          return partitionsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder setPartitions(
          int index, chromeos_update_engine.UpdateMetadata.PartitionUpdate value) {
        if (partitionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePartitionsIsMutable();
          partitions_.set(index, value);
          onChanged();
        } else {
          partitionsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder setPartitions(
          int index, chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder builderForValue) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          partitions_.set(index, builderForValue.build());
          onChanged();
        } else {
          partitionsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder addPartitions(chromeos_update_engine.UpdateMetadata.PartitionUpdate value) {
        if (partitionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePartitionsIsMutable();
          partitions_.add(value);
          onChanged();
        } else {
          partitionsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder addPartitions(
          int index, chromeos_update_engine.UpdateMetadata.PartitionUpdate value) {
        if (partitionsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePartitionsIsMutable();
          partitions_.add(index, value);
          onChanged();
        } else {
          partitionsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder addPartitions(
          chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder builderForValue) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          partitions_.add(builderForValue.build());
          onChanged();
        } else {
          partitionsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder addPartitions(
          int index, chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder builderForValue) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          partitions_.add(index, builderForValue.build());
          onChanged();
        } else {
          partitionsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder addAllPartitions(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.PartitionUpdate> values) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, partitions_);
          onChanged();
        } else {
          partitionsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder clearPartitions() {
        if (partitionsBuilder_ == null) {
          partitions_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          partitionsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public Builder removePartitions(int index) {
        if (partitionsBuilder_ == null) {
          ensurePartitionsIsMutable();
          partitions_.remove(index);
          onChanged();
        } else {
          partitionsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder getPartitionsBuilder(
          int index) {
        return getPartitionsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder getPartitionsOrBuilder(
          int index) {
        if (partitionsBuilder_ == null) {
          return partitions_.get(index);  } else {
          return partitionsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder> 
           getPartitionsOrBuilderList() {
        if (partitionsBuilder_ != null) {
          return partitionsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(partitions_);
        }
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder addPartitionsBuilder() {
        return getPartitionsFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.PartitionUpdate.getDefaultInstance());
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder addPartitionsBuilder(
          int index) {
        return getPartitionsFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.PartitionUpdate.getDefaultInstance());
      }
      /**
       * <pre>
       * Only present in major version &gt;= 2. List of partitions that will be
       * updated, in the order they will be updated. This field replaces the
       * |install_operations|, |kernel_install_operations| and the
       * |{old,new}_{kernel,rootfs}_info| fields used in major version = 1. This
       * array can have more than two partitions if needed, and they are identified
       * by the partition name.
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.PartitionUpdate partitions = 13;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder> 
           getPartitionsBuilderList() {
        return getPartitionsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.PartitionUpdate, chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder, chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder> 
          getPartitionsFieldBuilder() {
        if (partitionsBuilder_ == null) {
          partitionsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.PartitionUpdate, chromeos_update_engine.UpdateMetadata.PartitionUpdate.Builder, chromeos_update_engine.UpdateMetadata.PartitionUpdateOrBuilder>(
                  partitions_,
                  ((bitField0_ & 0x00000010) != 0),
                  getParentForChildren(),
                  isClean());
          partitions_ = null;
        }
        return partitionsBuilder_;
      }

      private long maxTimestamp_ ;
      /**
       * <pre>
       * The maximum timestamp of the OS allowed to apply this payload.
       * Can be used to prevent downgrading the OS.
       * </pre>
       *
       * <code>optional int64 max_timestamp = 14;</code>
       * @return Whether the maxTimestamp field is set.
       */
      @java.lang.Override
      public boolean hasMaxTimestamp() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * The maximum timestamp of the OS allowed to apply this payload.
       * Can be used to prevent downgrading the OS.
       * </pre>
       *
       * <code>optional int64 max_timestamp = 14;</code>
       * @return The maxTimestamp.
       */
      @java.lang.Override
      public long getMaxTimestamp() {
        return maxTimestamp_;
      }
      /**
       * <pre>
       * The maximum timestamp of the OS allowed to apply this payload.
       * Can be used to prevent downgrading the OS.
       * </pre>
       *
       * <code>optional int64 max_timestamp = 14;</code>
       * @param value The maxTimestamp to set.
       * @return This builder for chaining.
       */
      public Builder setMaxTimestamp(long value) {
        
        maxTimestamp_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum timestamp of the OS allowed to apply this payload.
       * Can be used to prevent downgrading the OS.
       * </pre>
       *
       * <code>optional int64 max_timestamp = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxTimestamp() {
        bitField0_ = (bitField0_ & ~0x00000020);
        maxTimestamp_ = 0L;
        onChanged();
        return this;
      }

      private chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata dynamicPartitionMetadata_;
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadataOrBuilder> dynamicPartitionMetadataBuilder_;
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       * @return Whether the dynamicPartitionMetadata field is set.
       */
      public boolean hasDynamicPartitionMetadata() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       * @return The dynamicPartitionMetadata.
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata getDynamicPartitionMetadata() {
        if (dynamicPartitionMetadataBuilder_ == null) {
          return dynamicPartitionMetadata_ == null ? chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.getDefaultInstance() : dynamicPartitionMetadata_;
        } else {
          return dynamicPartitionMetadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public Builder setDynamicPartitionMetadata(chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata value) {
        if (dynamicPartitionMetadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          dynamicPartitionMetadata_ = value;
        } else {
          dynamicPartitionMetadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public Builder setDynamicPartitionMetadata(
          chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder builderForValue) {
        if (dynamicPartitionMetadataBuilder_ == null) {
          dynamicPartitionMetadata_ = builderForValue.build();
        } else {
          dynamicPartitionMetadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public Builder mergeDynamicPartitionMetadata(chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata value) {
        if (dynamicPartitionMetadataBuilder_ == null) {
          if (((bitField0_ & 0x00000040) != 0) &&
            dynamicPartitionMetadata_ != null &&
            dynamicPartitionMetadata_ != chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.getDefaultInstance()) {
            getDynamicPartitionMetadataBuilder().mergeFrom(value);
          } else {
            dynamicPartitionMetadata_ = value;
          }
        } else {
          dynamicPartitionMetadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public Builder clearDynamicPartitionMetadata() {
        bitField0_ = (bitField0_ & ~0x00000040);
        dynamicPartitionMetadata_ = null;
        if (dynamicPartitionMetadataBuilder_ != null) {
          dynamicPartitionMetadataBuilder_.dispose();
          dynamicPartitionMetadataBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder getDynamicPartitionMetadataBuilder() {
        bitField0_ |= 0x00000040;
        onChanged();
        return getDynamicPartitionMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      public chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadataOrBuilder getDynamicPartitionMetadataOrBuilder() {
        if (dynamicPartitionMetadataBuilder_ != null) {
          return dynamicPartitionMetadataBuilder_.getMessageOrBuilder();
        } else {
          return dynamicPartitionMetadata_ == null ?
              chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.getDefaultInstance() : dynamicPartitionMetadata_;
        }
      }
      /**
       * <pre>
       * Metadata related to all dynamic partitions.
       * </pre>
       *
       * <code>optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadataOrBuilder> 
          getDynamicPartitionMetadataFieldBuilder() {
        if (dynamicPartitionMetadataBuilder_ == null) {
          dynamicPartitionMetadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadata.Builder, chromeos_update_engine.UpdateMetadata.DynamicPartitionMetadataOrBuilder>(
                  getDynamicPartitionMetadata(),
                  getParentForChildren(),
                  isClean());
          dynamicPartitionMetadata_ = null;
        }
        return dynamicPartitionMetadataBuilder_;
      }

      private boolean partialUpdate_ ;
      /**
       * <pre>
       * If the payload only updates a subset of partitions on the device.
       * </pre>
       *
       * <code>optional bool partial_update = 16;</code>
       * @return Whether the partialUpdate field is set.
       */
      @java.lang.Override
      public boolean hasPartialUpdate() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * If the payload only updates a subset of partitions on the device.
       * </pre>
       *
       * <code>optional bool partial_update = 16;</code>
       * @return The partialUpdate.
       */
      @java.lang.Override
      public boolean getPartialUpdate() {
        return partialUpdate_;
      }
      /**
       * <pre>
       * If the payload only updates a subset of partitions on the device.
       * </pre>
       *
       * <code>optional bool partial_update = 16;</code>
       * @param value The partialUpdate to set.
       * @return This builder for chaining.
       */
      public Builder setPartialUpdate(boolean value) {
        
        partialUpdate_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If the payload only updates a subset of partitions on the device.
       * </pre>
       *
       * <code>optional bool partial_update = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearPartialUpdate() {
        bitField0_ = (bitField0_ & ~0x00000080);
        partialUpdate_ = false;
        onChanged();
        return this;
      }

      private java.util.List<chromeos_update_engine.UpdateMetadata.ApexInfo> apexInfo_ =
        java.util.Collections.emptyList();
      private void ensureApexInfoIsMutable() {
        if (!((bitField0_ & 0x00000100) != 0)) {
          apexInfo_ = new java.util.ArrayList<chromeos_update_engine.UpdateMetadata.ApexInfo>(apexInfo_);
          bitField0_ |= 0x00000100;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.ApexInfo, chromeos_update_engine.UpdateMetadata.ApexInfo.Builder, chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder> apexInfoBuilder_;

      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.ApexInfo> getApexInfoList() {
        if (apexInfoBuilder_ == null) {
          return java.util.Collections.unmodifiableList(apexInfo_);
        } else {
          return apexInfoBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public int getApexInfoCount() {
        if (apexInfoBuilder_ == null) {
          return apexInfo_.size();
        } else {
          return apexInfoBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ApexInfo getApexInfo(int index) {
        if (apexInfoBuilder_ == null) {
          return apexInfo_.get(index);
        } else {
          return apexInfoBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public Builder setApexInfo(
          int index, chromeos_update_engine.UpdateMetadata.ApexInfo value) {
        if (apexInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureApexInfoIsMutable();
          apexInfo_.set(index, value);
          onChanged();
        } else {
          apexInfoBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public Builder setApexInfo(
          int index, chromeos_update_engine.UpdateMetadata.ApexInfo.Builder builderForValue) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.set(index, builderForValue.build());
          onChanged();
        } else {
          apexInfoBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public Builder addApexInfo(chromeos_update_engine.UpdateMetadata.ApexInfo value) {
        if (apexInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureApexInfoIsMutable();
          apexInfo_.add(value);
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public Builder addApexInfo(
          int index, chromeos_update_engine.UpdateMetadata.ApexInfo value) {
        if (apexInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureApexInfoIsMutable();
          apexInfo_.add(index, value);
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public Builder addApexInfo(
          chromeos_update_engine.UpdateMetadata.ApexInfo.Builder builderForValue) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.add(builderForValue.build());
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public Builder addApexInfo(
          int index, chromeos_update_engine.UpdateMetadata.ApexInfo.Builder builderForValue) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.add(index, builderForValue.build());
          onChanged();
        } else {
          apexInfoBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public Builder addAllApexInfo(
          java.lang.Iterable<? extends chromeos_update_engine.UpdateMetadata.ApexInfo> values) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, apexInfo_);
          onChanged();
        } else {
          apexInfoBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public Builder clearApexInfo() {
        if (apexInfoBuilder_ == null) {
          apexInfo_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000100);
          onChanged();
        } else {
          apexInfoBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public Builder removeApexInfo(int index) {
        if (apexInfoBuilder_ == null) {
          ensureApexInfoIsMutable();
          apexInfo_.remove(index);
          onChanged();
        } else {
          apexInfoBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ApexInfo.Builder getApexInfoBuilder(
          int index) {
        return getApexInfoFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder getApexInfoOrBuilder(
          int index) {
        if (apexInfoBuilder_ == null) {
          return apexInfo_.get(index);  } else {
          return apexInfoBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public java.util.List<? extends chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder> 
           getApexInfoOrBuilderList() {
        if (apexInfoBuilder_ != null) {
          return apexInfoBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(apexInfo_);
        }
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ApexInfo.Builder addApexInfoBuilder() {
        return getApexInfoFieldBuilder().addBuilder(
            chromeos_update_engine.UpdateMetadata.ApexInfo.getDefaultInstance());
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public chromeos_update_engine.UpdateMetadata.ApexInfo.Builder addApexInfoBuilder(
          int index) {
        return getApexInfoFieldBuilder().addBuilder(
            index, chromeos_update_engine.UpdateMetadata.ApexInfo.getDefaultInstance());
      }
      /**
       * <pre>
       * Information on compressed APEX to figure out how much space is required for
       * their decompression
       * </pre>
       *
       * <code>repeated .chromeos_update_engine.ApexInfo apex_info = 17;</code>
       */
      public java.util.List<chromeos_update_engine.UpdateMetadata.ApexInfo.Builder> 
           getApexInfoBuilderList() {
        return getApexInfoFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          chromeos_update_engine.UpdateMetadata.ApexInfo, chromeos_update_engine.UpdateMetadata.ApexInfo.Builder, chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder> 
          getApexInfoFieldBuilder() {
        if (apexInfoBuilder_ == null) {
          apexInfoBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              chromeos_update_engine.UpdateMetadata.ApexInfo, chromeos_update_engine.UpdateMetadata.ApexInfo.Builder, chromeos_update_engine.UpdateMetadata.ApexInfoOrBuilder>(
                  apexInfo_,
                  ((bitField0_ & 0x00000100) != 0),
                  getParentForChildren(),
                  isClean());
          apexInfo_ = null;
        }
        return apexInfoBuilder_;
      }

      private java.lang.Object securityPatchLevel_ = "";
      /**
       * <pre>
       * Security patch level of the device, usually in the format of
       * yyyy-mm-dd
       * </pre>
       *
       * <code>optional string security_patch_level = 18;</code>
       * @return Whether the securityPatchLevel field is set.
       */
      public boolean hasSecurityPatchLevel() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Security patch level of the device, usually in the format of
       * yyyy-mm-dd
       * </pre>
       *
       * <code>optional string security_patch_level = 18;</code>
       * @return The securityPatchLevel.
       */
      public java.lang.String getSecurityPatchLevel() {
        java.lang.Object ref = securityPatchLevel_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            securityPatchLevel_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Security patch level of the device, usually in the format of
       * yyyy-mm-dd
       * </pre>
       *
       * <code>optional string security_patch_level = 18;</code>
       * @return The bytes for securityPatchLevel.
       */
      public com.google.protobuf.ByteString
          getSecurityPatchLevelBytes() {
        java.lang.Object ref = securityPatchLevel_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          securityPatchLevel_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Security patch level of the device, usually in the format of
       * yyyy-mm-dd
       * </pre>
       *
       * <code>optional string security_patch_level = 18;</code>
       * @param value The securityPatchLevel to set.
       * @return This builder for chaining.
       */
      public Builder setSecurityPatchLevel(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        securityPatchLevel_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Security patch level of the device, usually in the format of
       * yyyy-mm-dd
       * </pre>
       *
       * <code>optional string security_patch_level = 18;</code>
       * @return This builder for chaining.
       */
      public Builder clearSecurityPatchLevel() {
        securityPatchLevel_ = getDefaultInstance().getSecurityPatchLevel();
        bitField0_ = (bitField0_ & ~0x00000200);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Security patch level of the device, usually in the format of
       * yyyy-mm-dd
       * </pre>
       *
       * <code>optional string security_patch_level = 18;</code>
       * @param value The bytes for securityPatchLevel to set.
       * @return This builder for chaining.
       */
      public Builder setSecurityPatchLevelBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        securityPatchLevel_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:chromeos_update_engine.DeltaArchiveManifest)
    }

    // @@protoc_insertion_point(class_scope:chromeos_update_engine.DeltaArchiveManifest)
    private static final chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest();
    }

    public static chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<DeltaArchiveManifest>
        PARSER = new com.google.protobuf.AbstractParser<DeltaArchiveManifest>() {
      @java.lang.Override
      public DeltaArchiveManifest parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DeltaArchiveManifest> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DeltaArchiveManifest> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public chromeos_update_engine.UpdateMetadata.DeltaArchiveManifest getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_Extent_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_Extent_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_Signatures_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_Signatures_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_Signatures_Signature_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_Signatures_Signature_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_PartitionInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_PartitionInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_InstallOperation_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_InstallOperation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_CowMergeOperation_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_CowMergeOperation_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_PartitionUpdate_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_PartitionUpdate_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_DynamicPartitionGroup_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_VABCFeatureSet_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_VABCFeatureSet_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_DynamicPartitionMetadata_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_ApexInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_ApexInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_ApexMetadata_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_ApexMetadata_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_chromeos_update_engine_DeltaArchiveManifest_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\025update_metadata.proto\022\026chromeos_update" +
      "_engine\"1\n\006Extent\022\023\n\013start_block\030\001 \001(\004\022\022" +
      "\n\nnum_blocks\030\002 \001(\004\"\237\001\n\nSignatures\022@\n\nsig" +
      "natures\030\001 \003(\0132,.chromeos_update_engine.S" +
      "ignatures.Signature\032O\n\tSignature\022\023\n\007vers" +
      "ion\030\001 \001(\rB\002\030\001\022\014\n\004data\030\002 \001(\014\022\037\n\027unpadded_" +
      "signature_size\030\003 \001(\007\"+\n\rPartitionInfo\022\014\n" +
      "\004size\030\001 \001(\004\022\014\n\004hash\030\002 \001(\014\"\246\004\n\020InstallOpe" +
      "ration\022;\n\004type\030\001 \002(\0162-.chromeos_update_e" +
      "ngine.InstallOperation.Type\022\023\n\013data_offs" +
      "et\030\002 \001(\004\022\023\n\013data_length\030\003 \001(\004\0223\n\013src_ext" +
      "ents\030\004 \003(\0132\036.chromeos_update_engine.Exte" +
      "nt\022\022\n\nsrc_length\030\005 \001(\004\0223\n\013dst_extents\030\006 " +
      "\003(\0132\036.chromeos_update_engine.Extent\022\022\n\nd" +
      "st_length\030\007 \001(\004\022\030\n\020data_sha256_hash\030\010 \001(" +
      "\014\022\027\n\017src_sha256_hash\030\t \001(\014\"\345\001\n\004Type\022\013\n\007R" +
      "EPLACE\020\000\022\016\n\nREPLACE_BZ\020\001\022\014\n\004MOVE\020\002\032\002\010\001\022\016" +
      "\n\006BSDIFF\020\003\032\002\010\001\022\017\n\013SOURCE_COPY\020\004\022\021\n\rSOURC" +
      "E_BSDIFF\020\005\022\016\n\nREPLACE_XZ\020\010\022\010\n\004ZERO\020\006\022\013\n\007" +
      "DISCARD\020\007\022\021\n\rBROTLI_BSDIFF\020\n\022\014\n\010PUFFDIFF" +
      "\020\t\022\014\n\010ZUCCHINI\020\013\022\022\n\016LZ4DIFF_BSDIFF\020\014\022\024\n\020" +
      "LZ4DIFF_PUFFDIFF\020\r\"\201\002\n\021CowMergeOperation" +
      "\022<\n\004type\030\001 \001(\0162..chromeos_update_engine." +
      "CowMergeOperation.Type\0222\n\nsrc_extent\030\002 \001" +
      "(\0132\036.chromeos_update_engine.Extent\0222\n\nds" +
      "t_extent\030\003 \001(\0132\036.chromeos_update_engine." +
      "Extent\022\022\n\nsrc_offset\030\004 \001(\r\"2\n\004Type\022\014\n\010CO" +
      "W_COPY\020\000\022\013\n\007COW_XOR\020\001\022\017\n\013COW_REPLACE\020\002\"\310" +
      "\006\n\017PartitionUpdate\022\026\n\016partition_name\030\001 \002" +
      "(\t\022\027\n\017run_postinstall\030\002 \001(\010\022\030\n\020postinsta" +
      "ll_path\030\003 \001(\t\022\027\n\017filesystem_type\030\004 \001(\t\022M" +
      "\n\027new_partition_signature\030\005 \003(\0132,.chrome" +
      "os_update_engine.Signatures.Signature\022A\n" +
      "\022old_partition_info\030\006 \001(\0132%.chromeos_upd" +
      "ate_engine.PartitionInfo\022A\n\022new_partitio" +
      "n_info\030\007 \001(\0132%.chromeos_update_engine.Pa" +
      "rtitionInfo\022<\n\noperations\030\010 \003(\0132(.chrome" +
      "os_update_engine.InstallOperation\022\034\n\024pos" +
      "tinstall_optional\030\t \001(\010\022=\n\025hash_tree_dat" +
      "a_extent\030\n \001(\0132\036.chromeos_update_engine." +
      "Extent\0228\n\020hash_tree_extent\030\013 \001(\0132\036.chrom" +
      "eos_update_engine.Extent\022\033\n\023hash_tree_al" +
      "gorithm\030\014 \001(\t\022\026\n\016hash_tree_salt\030\r \001(\014\0227\n" +
      "\017fec_data_extent\030\016 \001(\0132\036.chromeos_update" +
      "_engine.Extent\0222\n\nfec_extent\030\017 \001(\0132\036.chr" +
      "omeos_update_engine.Extent\022\024\n\tfec_roots\030" +
      "\020 \001(\r:\0012\022\017\n\007version\030\021 \001(\t\022C\n\020merge_opera" +
      "tions\030\022 \003(\0132).chromeos_update_engine.Cow" +
      "MergeOperation\022\031\n\021estimate_cow_size\030\023 \001(" +
      "\004\"L\n\025DynamicPartitionGroup\022\014\n\004name\030\001 \002(\t" +
      "\022\014\n\004size\030\002 \001(\004\022\027\n\017partition_names\030\003 \003(\t\"" +
      "8\n\016VABCFeatureSet\022\020\n\010threaded\030\001 \001(\010\022\024\n\014b" +
      "atch_writes\030\002 \001(\010\"\200\002\n\030DynamicPartitionMe" +
      "tadata\022=\n\006groups\030\001 \003(\0132-.chromeos_update" +
      "_engine.DynamicPartitionGroup\022\030\n\020snapsho" +
      "t_enabled\030\002 \001(\010\022\024\n\014vabc_enabled\030\003 \001(\010\022\036\n" +
      "\026vabc_compression_param\030\004 \001(\t\022\023\n\013cow_ver" +
      "sion\030\005 \001(\r\022@\n\020vabc_feature_set\030\006 \001(\0132&.c" +
      "hromeos_update_engine.VABCFeatureSet\"c\n\010" +
      "ApexInfo\022\024\n\014package_name\030\001 \001(\t\022\017\n\007versio" +
      "n\030\002 \001(\003\022\025\n\ris_compressed\030\003 \001(\010\022\031\n\021decomp" +
      "ressed_size\030\004 \001(\003\"C\n\014ApexMetadata\0223\n\tape" +
      "x_info\030\001 \003(\0132 .chromeos_update_engine.Ap" +
      "exInfo\"\303\003\n\024DeltaArchiveManifest\022\030\n\nblock" +
      "_size\030\003 \001(\r:\0044096\022\031\n\021signatures_offset\030\004" +
      " \001(\004\022\027\n\017signatures_size\030\005 \001(\004\022\030\n\rminor_v" +
      "ersion\030\014 \001(\r:\0010\022;\n\npartitions\030\r \003(\0132\'.ch" +
      "romeos_update_engine.PartitionUpdate\022\025\n\r" +
      "max_timestamp\030\016 \001(\003\022T\n\032dynamic_partition" +
      "_metadata\030\017 \001(\01320.chromeos_update_engine" +
      ".DynamicPartitionMetadata\022\026\n\016partial_upd" +
      "ate\030\020 \001(\010\0223\n\tapex_info\030\021 \003(\0132 .chromeos_" +
      "update_engine.ApexInfo\022\034\n\024security_patch" +
      "_level\030\022 \001(\tJ\004\010\001\020\002J\004\010\002\020\003J\004\010\006\020\007J\004\010\007\020\010J\004\010\010" +
      "\020\tJ\004\010\t\020\nJ\004\010\n\020\013J\004\010\013\020\014"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_chromeos_update_engine_Extent_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_chromeos_update_engine_Extent_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_Extent_descriptor,
        new java.lang.String[] { "StartBlock", "NumBlocks", });
    internal_static_chromeos_update_engine_Signatures_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_chromeos_update_engine_Signatures_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_Signatures_descriptor,
        new java.lang.String[] { "Signatures", });
    internal_static_chromeos_update_engine_Signatures_Signature_descriptor =
      internal_static_chromeos_update_engine_Signatures_descriptor.getNestedTypes().get(0);
    internal_static_chromeos_update_engine_Signatures_Signature_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_Signatures_Signature_descriptor,
        new java.lang.String[] { "Version", "Data", "UnpaddedSignatureSize", });
    internal_static_chromeos_update_engine_PartitionInfo_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_chromeos_update_engine_PartitionInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_PartitionInfo_descriptor,
        new java.lang.String[] { "Size", "Hash", });
    internal_static_chromeos_update_engine_InstallOperation_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_chromeos_update_engine_InstallOperation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_InstallOperation_descriptor,
        new java.lang.String[] { "Type", "DataOffset", "DataLength", "SrcExtents", "SrcLength", "DstExtents", "DstLength", "DataSha256Hash", "SrcSha256Hash", });
    internal_static_chromeos_update_engine_CowMergeOperation_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_chromeos_update_engine_CowMergeOperation_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_CowMergeOperation_descriptor,
        new java.lang.String[] { "Type", "SrcExtent", "DstExtent", "SrcOffset", });
    internal_static_chromeos_update_engine_PartitionUpdate_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_chromeos_update_engine_PartitionUpdate_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_PartitionUpdate_descriptor,
        new java.lang.String[] { "PartitionName", "RunPostinstall", "PostinstallPath", "FilesystemType", "NewPartitionSignature", "OldPartitionInfo", "NewPartitionInfo", "Operations", "PostinstallOptional", "HashTreeDataExtent", "HashTreeExtent", "HashTreeAlgorithm", "HashTreeSalt", "FecDataExtent", "FecExtent", "FecRoots", "Version", "MergeOperations", "EstimateCowSize", });
    internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_chromeos_update_engine_DynamicPartitionGroup_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_DynamicPartitionGroup_descriptor,
        new java.lang.String[] { "Name", "Size", "PartitionNames", });
    internal_static_chromeos_update_engine_VABCFeatureSet_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_chromeos_update_engine_VABCFeatureSet_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_VABCFeatureSet_descriptor,
        new java.lang.String[] { "Threaded", "BatchWrites", });
    internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_chromeos_update_engine_DynamicPartitionMetadata_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_DynamicPartitionMetadata_descriptor,
        new java.lang.String[] { "Groups", "SnapshotEnabled", "VabcEnabled", "VabcCompressionParam", "CowVersion", "VabcFeatureSet", });
    internal_static_chromeos_update_engine_ApexInfo_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_chromeos_update_engine_ApexInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_ApexInfo_descriptor,
        new java.lang.String[] { "PackageName", "Version", "IsCompressed", "DecompressedSize", });
    internal_static_chromeos_update_engine_ApexMetadata_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_chromeos_update_engine_ApexMetadata_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_ApexMetadata_descriptor,
        new java.lang.String[] { "ApexInfo", });
    internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_chromeos_update_engine_DeltaArchiveManifest_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_chromeos_update_engine_DeltaArchiveManifest_descriptor,
        new java.lang.String[] { "BlockSize", "SignaturesOffset", "SignaturesSize", "MinorVersion", "Partitions", "MaxTimestamp", "DynamicPartitionMetadata", "PartialUpdate", "ApexInfo", "SecurityPatchLevel", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
